<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JDK源码分析之——Condition | 米兰半岛铁盒</title><meta name="keywords" content="Java,多线程,高并发,源码分析"><meta name="author" content="Silence"><meta name="copyright" content="Silence"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition。 Condition能实现synchronized和wait、notify搭">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK源码分析之——Condition">
<meta property="og:url" content="https://silentao.com/10027/index.html">
<meta property="og:site_name" content="米兰半岛铁盒">
<meta property="og:description" content="简介Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition。 Condition能实现synchronized和wait、notify搭">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://silentao.com/img/default_page_img_01.jpeg">
<meta property="article:published_time" content="2020-06-14T09:42:00.000Z">
<meta property="article:modified_time" content="2022-09-04T09:46:17.463Z">
<meta property="article:author" content="Silence">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="高并发">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://silentao.com/img/default_page_img_01.jpeg"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="https://silentao.com/10027/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Silence","link":"链接: ","source":"来源: 米兰半岛铁盒","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JDK源码分析之——Condition',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-04 17:46:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_page_img_01.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">米兰半岛铁盒</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JDK源码分析之——Condition</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-14T09:42:00.000Z" title="发表于 2020-06-14 17:42:00">2020-06-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-04T09:46:17.463Z" title="更新于 2022-09-04 17:46:17">2022-09-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JDK源码分析之——Condition"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition。</p>
<p>Condition能实现synchronized和wait、notify搭配的功能，另外比后者更灵活，Condition可以实现多路通知功能，也就是在一个Lock对象里可以创建多个Condition（即对象监视器）实例，线程对象可以注册在指定的Condition中，从而可以有选择的进行线程通知，在调度线程上更加灵活。而synchronized就相当于整个Lock对象中只有一个单一的Condition对象，所有的线程都注册在这个对象上。线程开始notifyAll时，需要通知所有的WAITING线程，没有选择权，会有相当大的效率问题。</p>
<p>这里要讲的是ReentrantLock（不了解ReentrantLock的同学可以看一下<a href="https://silentao.com/2020/05/29/10026/">JDK源码分析之——ReentrantLock</a>）中的Condition，Condition是一个接口，而ReentrantLock里使用的Condition是由AQS（AbstractQueuedSynchronizer，这里又要回到AQS了哈哈，不了解AQS的同学可以看看之前发布的<a href="https://silentao.com/2019/04/08/10016/">JDK源码分析之——AQS</a>）的内部类ConditionObject实现的。在ConditionObject内部维护了一个由Node（AQS里的另一个类）节点连接而成的等待队列，这个队列是一个单链表，同时ConditionObject还有指向单链表首尾节点的指针，方便对整个队列进行遍历。</p>
<p>流程图如下：<br><img src="/img/backend/10027/10027_1.png" alt="Condition流程图"></p>
<p>由于鄙人不善于作图，所以接下来会有大量的源码注释还有文字说明，如果有说得不清楚的地方，还望评论区指出哈</p>
<h2 id="1-ConditionObject的成员变量"><a href="#1-ConditionObject的成员变量" class="headerlink" title="1.ConditionObject的成员变量"></a>1.ConditionObject的成员变量</h2><p>ConditionObject的成员变量比较简单，包含两个分别指向队列头尾的指针和两种等待退出的模式，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向队列的头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向队列的尾指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在等待退出时重新标记中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在等待退出时抛出中断异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-await"><a href="#2-await" class="headerlink" title="2.await"></a>2.await</h2><p>await方法的作用就是释放当前线程持有的锁，然后将当前线程挂起，直到有其它线程将它唤醒或者被中断。在源码讲解前，先来做个名称解释：</p>
<ul>
<li>同步队列：指的是在AQS中等待获取资源的队列，由AQS控制；</li>
<li>等待队列：指的是调用await方法之后等待被signal唤醒的队列，由AQS内部类ConditionObject控制。</li>
</ul>
<p>await方法具体流程如下：</p>
<ol>
<li>如果线程被中断，直接抛出中断异常；</li>
<li>创建一个状态为CONDITION的Node节点，并将节点放在等待队列的队尾；</li>
<li>完全释放线程占有的全部资源；</li>
<li>循环判断Node节点是否不在同步队列中，然后将当前线程挂起，否则退出循环，如果线程被中断也会退出循环；</li>
<li>尝试去同步队列中获取所需要的资源，如果暂时拿不到就挂起当前线程，直到当前节点变成同步队列的第二个节点时被唤醒；</li>
<li>如果当前节点在等待队列中还有后继节点，说明当前线程是被中断唤醒的，这个时候要把等待队列中不是CONDITION状态的节点清理掉；</li>
<li>根据interruptMode的值来决定是否需要抛出中断异常或者重新标记中断。</li>
</ol>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">// 如果线程被中断过，就直接抛出中断异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 创建一个状态为CONDITION的Node节点，并将节点放在等待队列的队尾</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 完全释放线程占有的全部资源</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="comment">// 标记线程最后退出的模式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// node节点不在同步队列中（指的是AQS的同步队列）</span></span><br><span class="line">        <span class="comment">// 当前线程被其它线程唤醒时</span></span><br><span class="line">        <span class="comment">// node节点就会被加入到同步队列的队尾，这时自然会退出循环</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挂起当前线程</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果线程被中断，直接退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试去同步队列中获取所需要的资源（这个方法在讲AQS的文章里讲过，这里不再复述）</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">// 如果线程在获取资源时被中断并且不是以抛异常的形式退出</span></span><br><span class="line">        <span class="comment">// 那就将退出模式置为为重新标记中断</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        <span class="comment">// 当前节点在等待队列中还有后继节点</span></span><br><span class="line">        <span class="comment">// 说明当前线程是被中断唤醒的</span></span><br><span class="line">        <span class="comment">// 被正常唤醒的节点的后继节点会被置为null且会被放在同步队列的队尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把等待队列中不是CONDITION状态的节点清理掉    </span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 表示非正常唤醒（因中断被唤醒）</span></span><br><span class="line">        <span class="comment">// 那就根据interruptMode标记的值来决定是抛出异常还是重新标记中断</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-addConditionWaiter"><a href="#2-1-addConditionWaiter" class="headerlink" title="2.1 addConditionWaiter"></a>2.1 addConditionWaiter</h3><p>addConditionWaiter方法用来创建一个状态为CONDITION的新Node节点，并添加等待队列尾部，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 清理状态不是CONDITION节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 再次获取尾节点</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个状态为CONDITION的新Node节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新节点添加到等待队列尾部</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-fullyRelease"><a href="#2-2-fullyRelease" class="headerlink" title="2.2 fullyRelease"></a>2.2 fullyRelease</h3><p>fullyRelease方法的作用是释放线程持有的所有的资源，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放线程持有的所有资源（该方法是QAS的方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 用来标记过程是否是失败</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程占用的所有资源</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            <span class="comment">// 成功释放资源</span></span><br><span class="line">            <span class="comment">// 将失败标记置为false</span></span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 返回释放的资源</span></span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源失败则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 资源释放失败就将当前节点标记为CANCELLED（取消状态）</span></span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-isOnSyncQueue"><a href="#2-3-isOnSyncQueue" class="headerlink" title="2.3 isOnSyncQueue"></a>2.3 isOnSyncQueue</h3><p>isOnSyncQueue方法是用来判断node节点是否在同步队列，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * node节点是否在同步队列中（该方法是QAS的方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 如果节点状态为CONDITION</span></span><br><span class="line">        <span class="comment">// 或者node节点的前继节点为空，那么node肯定不在同步队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有两种情况node节点的前继节点会为空</span></span><br><span class="line">        <span class="comment">// 1.node节点不在同步队列里；</span></span><br><span class="line">        <span class="comment">// 2.node节点是同步队列的头结点。</span></span><br><span class="line">        <span class="comment">// 很显然这里不会是同步队列的头结点</span></span><br><span class="line">        <span class="comment">// 因为同步队列头结点的是持有资源的线程对应的节点</span></span><br><span class="line">        <span class="comment">// 如果持有资源的线程调用await方法到这里的node</span></span><br><span class="line">        <span class="comment">// 已经不是同步队列头结点的那个node了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果node有后继节点，那么肯定是在同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node的前继节点为非空，并不意味着node就在同步队列中</span></span><br><span class="line">    <span class="comment">// 因为CAS操作在将node节点加入到同步队列时可能失败</span></span><br><span class="line">    <span class="comment">// 所以我们必须确保node节点已经在同步队列中</span></span><br><span class="line">    <span class="comment">// 那么就需要从同步队列的尾部遍历</span></span><br><span class="line">    <span class="comment">// 看node节点是否在同步队列中</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从同步队列尾部遍历看node节点是否在同步队列中（该方法是QAS的私有方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取同步队列的尾部节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="comment">// 节点在同步队列中，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-checkInterruptWhileWaiting"><a href="#2-4-checkInterruptWhileWaiting" class="headerlink" title="2.4 checkInterruptWhileWaiting"></a>2.4 checkInterruptWhileWaiting</h3><p>checkInterruptWhileWaiting方法主要是校验node节点对应的线程是否被中断唤醒，如果是在被signal唤醒之前被中断就返回THROW_IE（表示在退出时要抛出中断异常），如果是在被signal唤醒之后被中断则返回REINTERRUPT（表示在退出时要重新标记中断），如果是被signal唤醒没有被中断则返回0（表示线程整个挂起的过程中都没有被中断），源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断中断发生的时机（该方法是QAS的私有方法）</span></span><br><span class="line"><span class="comment"> * 返回true：表示在被signal唤醒之前被中断</span></span><br><span class="line"><span class="comment"> * 返回false：表示在被signal唤醒之后被中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 通过CAS将node节点的状态修改为0</span></span><br><span class="line">        <span class="comment">// 成功表示此时node节点还在等待队列中</span></span><br><span class="line">        <span class="comment">// 间接表明此时的node节点是被中断唤醒的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将node节点加入到同步队列尾部</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到了这里说明中断是在被signal唤醒之后发生的</span></span><br><span class="line">    <span class="comment">// 此时我们需要保证node节点已经在同步队列中</span></span><br><span class="line">    <span class="comment">// 才能继续往下执行</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        <span class="comment">// 如果node不在同步队列中，那么调用线程让步</span></span><br><span class="line">        <span class="comment">// 直到node节点已经在同步队列中为止</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-unlinkCancelledWaiters"><a href="#2-5-unlinkCancelledWaiters" class="headerlink" title="2.5 unlinkCancelledWaiters"></a>2.5 unlinkCancelledWaiters</h3><p>unlinkCancelledWaiters方法的作用是删除等待队列中不是CONDITION状态的节点，从头开始挨个遍历每个节点，删除状态不是CONDITION状态的节点，也就是单链表的节点删除操作，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从等待队列中删除状态不是CONDITION状态的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取头节点，从头节点开始遍历</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点状态不是CONDITION就从链表中删除</span></span><br><span class="line">            t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// next为空表示当前节点是最后一个节点</span></span><br><span class="line">            <span class="comment">// 将尾节点指针指向next</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-reportInterruptAfterWait"><a href="#2-6-reportInterruptAfterWait" class="headerlink" title="2.6 reportInterruptAfterWait"></a>2.6 reportInterruptAfterWait</h3><p>reportInterruptAfterWait方法控制线程退出时是抛出中断异常还是重新标记中断，源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * interruptMode == THROW_IE：抛出中断异常</span></span><br><span class="line"><span class="comment"> * interruptMode == REINTERRUPT：重新标记中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="comment">// 抛出中断异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        <span class="comment">// 重新标记中断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h3><p>await方法的源码分析在这里就告一段落啦，其中还有不响应中断的awaitUninterruptibly方法，带超时的awaitNanos和await方法以及指定超时截止时间的awaitUntil方法，逻辑大致和上面的await方法如出一辙，这里就不一一叙述啦，刚兴趣的同学可以自行研究。await方法会将线程占有的所有资源都释放掉，然后将线程挂起直到其它线程将它唤醒或者被中断。期间涉及到了node节点从等待队列到同步队列的转移，然后线程在同步队列中重新获取资源（即重新获得锁）后继续执行的整个过程。虽然过程不是很复杂，但是同时调用了内部类ConditionObject和AQS的方法，还需仔细品味等待队列和同步队列之间的关系，才能明白它们的巧妙之处。加油鸭！</p>
<h2 id="3-signal"><a href="#3-signal" class="headerlink" title="3.signal"></a>3.signal</h2><p>signal方法主要是将等待队列中等待最久的那个没有取消的node节点转移到同步队列中的尾部，使该node节点有在同步队列中等待获取资源（获得锁）的资格，得以继续执行await方法后面的逻辑。具体过程如下：</p>
<ol>
<li>判断当前线程是否为持有锁的线程，如果不是则抛出IllegalMonitorStateException异常；</li>
<li>获取等待队列中头结点，然后将头结点指针指向头结点的下一个节点，然后尝试将当前结点转移到同步队列的尾部；</li>
<li>如果当前节点在同步队列的前继节点已经取消或者修改其前继节点状态为SIGNAL失败时，换醒当前节点；</li>
<li>如果上述操作失败就重复2、3过程，直到成功将一个节点转移到同步队列，或者遍历完等待队列就结束整个过程。</li>
</ol>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试唤醒等待队列中等待了最近的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="comment">// 如果当前线程不是持有锁的线程</span></span><br><span class="line">        <span class="comment">// 抛出IllegalMonitorStateException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取等待队列的头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 头结点不为空，开始尝试唤醒头结点</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-doSignal"><a href="#3-1-doSignal" class="headerlink" title="3.1 doSignal"></a>3.1 doSignal</h3><p>doSignal主要是从等待队列头部开始遍历，然后将节点从等待队列中移除，并尝试将节点转移到同步队列中，直到有一个成功或者遍历完整个等待队列为止，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历等待队列并将相应节点从等待队列中移除</span></span><br><span class="line"><span class="comment"> * 然后尝试将节点转移到同步队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 将头部指针指向first.nextWaiter</span></span><br><span class="line">        <span class="comment">// 这里是要讲first节点删除掉</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// first.nextWaiter为空表示整个等待队列已经空了</span></span><br><span class="line">            <span class="comment">// 将等待队列尾部指针也置为空</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// first.nextWaiter置为空</span></span><br><span class="line">        <span class="comment">// 彻底将first断开</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试将first节点转移到同步队列中，有一次成功就退出循环</span></span><br><span class="line">        <span class="comment">// 或者遍历完整个等待队列时再退出</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将node节点转移到同步队列的尾部（该方法是QAS的方法）</span></span><br><span class="line"><span class="comment"> * 返回true表示成功转移</span></span><br><span class="line"><span class="comment"> * 返回false表示node可能已经取消或者已经转移过了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试将node节点状态修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// 修改失败可能node节点已经取消了或者已经转移到同步队列里了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将node节点转移到同步队列尾部并返回它的前继节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="comment">// 获取前继节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="comment">// 这一步应该是为了保证node节点的前继节点为SIGNAL状态</span></span><br><span class="line">    <span class="comment">// 好在前继执行完成时可以顺利唤醒node节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前继节点状态为取消</span></span><br><span class="line">        <span class="comment">// 或者修改前继节点状态为SIGNAL失败</span></span><br><span class="line">        <span class="comment">// 就唤醒node节点对应的线程</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node节点转移成功，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-小结"><a href="#3-2-小结" class="headerlink" title="3.2 小结"></a>3.2 小结</h3><p>signal方法主要是将在等待队列中等待了最久的且没有取消的一个节点转移到同步队列中，以便节点可以在同步队列中有再次获取资源的资格，可以继续完成后面的事情。而signalAll方法和signal方法唯一不同的是，signalAll方法是要将所有等待队列中未取消的节点转移到同步队列中，以便它们可以依次获取资源继续完成后面的事情，因为逻辑上差不多，这里也不再叙述，有兴趣的同学可以自己看看。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本篇讲述的是ReentrantLock中用到的条件变量Condition，是由AQS的内部类ConditionObject实现的，ConditionObject维护着一个以AQS内部类Node为节点的等待队列，这是一个单链表，等待队列里的都是调用了await方法后等待被唤醒的节点。ConditionObject主要用两个方法，await和signal方法。其中await方法主要是创建一个保存当前线程的Node节点并放在等待队列中，然后将线程持有的资源完全释放然后将线程挂起，直到线程被唤醒或被中断时，会将节点转移同步队列中，以便线程可以在同步队列中有再次获取资源的资格；而signal方法主要是将节点从等待队列转移到同步队列中，以便线程可以在同步队列中有再次获取资源的资格。await和signal需要配合使用，才能维护共享资源的同步。</p>
<p>源码虽然枯燥无味，但是它包含着精髓，同学们需要细细品味，加油鸭！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://silentao.com">Silence</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://silentao.com/10027/">https://silentao.com/10027/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://silentao.com" target="_blank">米兰半岛铁盒</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></div><div class="post_share"><div class="social-share" data-image="/img/default_page_img_01.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward-wepay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward-wepay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/reward-alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward-alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/10028/"><img class="prev-cover" src="/img/default_page_img_17.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring整体架构</div></div></a></div><div class="next-post pull-right"><a href="/10026/"><img class="next-cover" src="/img/default_page_img_03.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JDK源码分析之——ReentrantLock</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/10015/" title="JDK源码分析之——CountDownLatch与CyclicBarrier"><img class="cover" src="/img/default_page_img_16.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-09</div><div class="title">JDK源码分析之——CountDownLatch与CyclicBarrier</div></div></a></div><div><a href="/10016/" title="JDK源码分析之——AQS"><img class="cover" src="/img/default_page_img_19.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-08</div><div class="title">JDK源码分析之——AQS</div></div></a></div><div><a href="/10025/" title="JDK源码分析之——FutureTask"><img class="cover" src="/img/default_page_img_11.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-19</div><div class="title">JDK源码分析之——FutureTask</div></div></a></div><div><a href="/10026/" title="JDK源码分析之——ReentrantLock"><img class="cover" src="/img/default_page_img_03.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-29</div><div class="title">JDK源码分析之——ReentrantLock</div></div></a></div><div><a href="/10014/" title="Java并发中遇到的锁"><img class="cover" src="/img/default_page_img_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-08</div><div class="title">Java并发中遇到的锁</div></div></a></div><div><a href="/10019/" title="JDK源码分析之——ThreadLocal"><img class="cover" src="/img/default_page_img_20.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-13</div><div class="title">JDK源码分析之——ThreadLocal</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Silence</div><div class="author-info__description">米兰半岛铁盒-个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/silence-tao"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/silence-tao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:silentao@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">《大厂面试力扣算法题———CodeTop题解》系列文章持续更新中~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ConditionObject%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.ConditionObject的成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-await"><span class="toc-number">1.2.</span> <span class="toc-text">2.await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-addConditionWaiter"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 addConditionWaiter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-fullyRelease"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 fullyRelease</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-isOnSyncQueue"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 isOnSyncQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-checkInterruptWhileWaiting"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 checkInterruptWhileWaiting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-unlinkCancelledWaiters"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 unlinkCancelledWaiters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-reportInterruptAfterWait"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 reportInterruptAfterWait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-signal"><span class="toc-number">1.3.</span> <span class="toc-text">3.signal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-doSignal"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 doSignal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">4.总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/10031/" title="大厂面试力扣算法题———CodeTop题解（三）"><img src="/img/default_page_img_04.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大厂面试力扣算法题———CodeTop题解（三）"/></a><div class="content"><a class="title" href="/10031/" title="大厂面试力扣算法题———CodeTop题解（三）">大厂面试力扣算法题———CodeTop题解（三）</a><time datetime="2022-09-06T01:50:00.000Z" title="发表于 2022-09-06 09:50:00">2022-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10030/" title="大厂面试力扣算法题———CodeTop题解（二）"><img src="/img/default_page_img_15.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大厂面试力扣算法题———CodeTop题解（二）"/></a><div class="content"><a class="title" href="/10030/" title="大厂面试力扣算法题———CodeTop题解（二）">大厂面试力扣算法题———CodeTop题解（二）</a><time datetime="2022-09-05T01:50:00.000Z" title="发表于 2022-09-05 09:50:00">2022-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10029/" title="大厂面试力扣算法题———CodeTop题解（一）"><img src="/img/default_page_img_11.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大厂面试力扣算法题———CodeTop题解（一）"/></a><div class="content"><a class="title" href="/10029/" title="大厂面试力扣算法题———CodeTop题解（一）">大厂面试力扣算法题———CodeTop题解（一）</a><time datetime="2022-09-04T14:00:00.000Z" title="发表于 2022-09-04 22:00:00">2022-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10028/" title="Spring整体架构"><img src="/img/default_page_img_17.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring整体架构"/></a><div class="content"><a class="title" href="/10028/" title="Spring整体架构">Spring整体架构</a><time datetime="2021-03-06T07:56:00.000Z" title="发表于 2021-03-06 15:56:00">2021-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10027/" title="JDK源码分析之——Condition"><img src="/img/default_page_img_01.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK源码分析之——Condition"/></a><div class="content"><a class="title" href="/10027/" title="JDK源码分析之——Condition">JDK源码分析之——Condition</a><time datetime="2020-06-14T09:42:00.000Z" title="发表于 2020-06-14 17:42:00">2020-06-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By Silence</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><span>Copyright © 2019 <a href="//beian.miit.gov.cn/" target="_blank" rel="nofollow"> 赣ICP备16012352号-2</a> </span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>