<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大厂面试力扣算法题———CodeTop题解（三）</title>
      <link href="/10031/"/>
      <url>/10031/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://codetop.cc/">CodeTop</a> 用于汇总互联网大厂面试的高频考题帮助面试者更有针对性地准备面试。</p><p>《大厂面试力扣算法题———CodeTop题解》系列文章将致力于为 <a href="https://codetop.cc/">CodeTop</a> 中的前 100 道在大厂面试当中会高频出现的算法题写题解，希望能给将要或者正在找工作的同学提供参考，如果有帮助到你，那将是我的荣幸~</p><p>为了缩小篇幅，《大厂面试力扣算法题———CodeTop题解》系列文章将分成 10 篇文章持续推出，每篇文章将会有 10 道题目的题解。因为 <a href="https://codetop.cc/">CodeTop</a> 上的题目顺序是随着题目的热度一直在变动的，所以题解的顺序可能会和 <a href="https://codetop.cc/">CodeTop</a> 顺序不一致，特此说明。</p><p>那么接下来，让我们进入正题吧~</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>提示：</p><ul><li>m &#x3D;&#x3D; grid.length</li><li>n &#x3D;&#x3D; grid[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 300</li><li>grid[i][j] 的值为 ‘0’ 或 ‘1’</li></ul></blockquote><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length, sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// visited用来标记访问过的陆地</span></span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="comment">// 遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当遇到陆地时</span></span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 陆地加1</span></span><br><span class="line">                    sum++;</span><br><span class="line">                    <span class="comment">// 再进行深度优先搜索标记相连的陆地</span></span><br><span class="line">                    helper(grid, visited, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先搜索标记相连的陆地</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">boolean</span>[][] visited, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 遇到边界或者访问过的陆地或者非陆地时</span></span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visited[i][j] || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上右下左访问旁边的陆地</span></span><br><span class="line">        helper(grid, visited, i - <span class="number">1</span>, j);</span><br><span class="line">        helper(grid, visited, i, j + <span class="number">1</span>);</span><br><span class="line">        helper(grid, visited, i + <span class="number">1</span>, j);</span><br><span class="line">        helper(grid, visited, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></p><blockquote><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul></blockquote><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        helper(nums, <span class="number">0</span>, res, list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归全排列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> pos,</span></span><br><span class="line"><span class="params">                        List&lt;List&lt;Integer&gt;&gt; res,</span></span><br><span class="line"><span class="params">                        List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 如果已经递归到了最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (length == pos) &#123;</span><br><span class="line">            <span class="comment">// 那就将结果放入res</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素已经在list当中</span></span><br><span class="line">            <span class="keyword">if</span> (list.contains(nums[i])) &#123;</span><br><span class="line">                <span class="comment">// 那就直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前元素加入到list中</span></span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            <span class="comment">// 递归，pos加1</span></span><br><span class="line">            helper(nums, pos + <span class="number">1</span>, res, list);</span><br><span class="line">            <span class="comment">// 将当前元素移出list</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a></p><blockquote><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p><p>提示：</p><ul><li>1 &lt;&#x3D; num1.length, num2.length &lt;&#x3D; 104</li><li>num1 和num2 都只包含数字 0-9</li><li>num1 和num2 都不包含任何前导零</li></ul></blockquote><h3 id="倒序迭代"><a href="#倒序迭代" class="headerlink" title="倒序迭代"></a>倒序迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> num1.length(), len2 = num2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sum保存临时的和以及上次相加结果的进位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, i = len1 - <span class="number">1</span>, j = len2 - <span class="number">1</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 倒叙遍历两个字符串</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将字符转为数字</span></span><br><span class="line">                a = num1.charAt(i--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将字符转为数字</span></span><br><span class="line">                b = num2.charAt(j--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相加</span></span><br><span class="line">            sum += a + b;</span><br><span class="line">            <span class="comment">// 对10取余放到结果中</span></span><br><span class="line">            res.append(sum % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 除以10获取进位</span></span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果进位不为0</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 则将进位放入结果中</span></span><br><span class="line">            res.append(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转结果返回</span></span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></p><blockquote><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul></blockquote><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建h节点作为反转链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">// pre作为反转链表的前继节点</span></span><br><span class="line">        <span class="comment">// last作为反转后链表的最后一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>, last = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// pos记录遍历到了第几个节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历到链表的第right个节点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; pos++ &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果遍历到了第left个节点及以后的节点</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= pos) &#123;</span><br><span class="line">                <span class="comment">// left == pos时表示便利到了反转链表的第一个节点</span></span><br><span class="line">                <span class="comment">// 即反转后链表的最后一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (left == pos) &#123;</span><br><span class="line">                    <span class="comment">// 用last记录反转后链表的最后一个节点</span></span><br><span class="line">                    last = node;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 临时存放当前节点</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> node;</span><br><span class="line">                <span class="comment">// node跳到下一个节点</span></span><br><span class="line">                node = node.next;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 实现反转</span></span><br><span class="line">                <span class="comment">// 当前节点的next指向头节点的下一个节点</span></span><br><span class="line">                cur.next = h.next;</span><br><span class="line">                <span class="comment">// 头节点的next指向当前节点</span></span><br><span class="line">                h.next = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 在遍历到第left个节点前</span></span><br><span class="line">                <span class="comment">// 一直更新pre</span></span><br><span class="line">                pre = node;</span><br><span class="line">                <span class="comment">// node跳到下一个节点</span></span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果pre不为空表示left &gt; 1</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里需要把反转链表前面的节点连接上反转后的链表</span></span><br><span class="line">            pre.next = h.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (last != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将反转后的链表连接上反转链表后面的节点</span></span><br><span class="line">            last.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果left == 1直接返回h.next</span></span><br><span class="line">        <span class="comment">// 否则返回head</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">1</span> ? h.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p>难度：<mark class="hl-label red">困难</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></p><blockquote><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>提示：</p><ul><li>k &#x3D;&#x3D; lists.length</li><li>0 &lt;&#x3D; k &lt;&#x3D; 10^4</li><li>0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500</li><li>-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4</li><li>lists[i] 按 升序 排列</li><li>lists[i].length 的总和不超过 10^4</li></ul></blockquote><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用栈实现归并合并链表</span></span><br><span class="line">        LinkedList&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先遍历lists将所有链表放入stack中</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">            stack.push(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后将栈中的每两个链表弹出进行合并</span></span><br><span class="line">        <span class="comment">// 合并结果再放入栈中</span></span><br><span class="line">        <span class="comment">// 当栈中只剩下一个链表时停止合并</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            stack.push(merge(stack.pop(), stack.pop()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈中剩余的最后一个链表就是合并后的结果</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个升序链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode node1, ListNode node2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="literal">null</span> || node2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.next = node2;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.next = node1;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1.val &lt; node2.val) &#123;</span><br><span class="line">                node.next = node1;</span><br><span class="line"></span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = node2;</span><br><span class="line"></span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a>环形链表 II</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p><blockquote><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul></blockquote><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="comment">// 快指针每次跳一个节点</span></span><br><span class="line">        <span class="comment">// 慢指针每次跳两个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果链表有环，则快慢指针相遇，即slow == fast</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="comment">// 这时直接跳出循环</span></span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果快慢指针不相等，则链表无环</span></span><br><span class="line">        <span class="keyword">if</span> (slow != fast) &#123;</span><br><span class="line">            <span class="comment">// 直接返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 既然判定链表有环</span></span><br><span class="line">        <span class="comment">// 那让慢指针从头节点开始</span></span><br><span class="line">        <span class="comment">// 和快指针以相同的速度前进</span></span><br><span class="line">        <span class="comment">// 当两个快慢指针再次相遇时的节点</span></span><br><span class="line">        <span class="comment">// 就是环的起点</span></span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回快慢指针都是环的起点</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></p><blockquote><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p>提示：</p><ul><li>m &#x3D;&#x3D; matrix.length</li><li>n &#x3D;&#x3D; matrix[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 10</li><li>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</li></ul></blockquote><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上下左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>, d = m - <span class="number">1</span>, l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// move代表左下右上移动 0-&gt;1-&gt;2-&gt;3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">move</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// step代表移动了多少步</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> m * n, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (step-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(matrix[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (move == <span class="number">0</span>) &#123; <span class="comment">// 相右移动</span></span><br><span class="line">                <span class="keyword">if</span> (j == r) &#123;</span><br><span class="line">                    <span class="comment">// 转到下一层</span></span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="comment">// 移动方向转为向下</span></span><br><span class="line">                    move = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 上边界缩小1</span></span><br><span class="line">                    u++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">continue</span> ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向右移动一格</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == d) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                    move = <span class="number">2</span>;</span><br><span class="line">                    r--;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">continue</span> ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == l) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                    move = <span class="number">3</span>;</span><br><span class="line">                    d--;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">continue</span> ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == u) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    move = <span class="number">0</span>;</span><br><span class="line">                    l++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">continue</span> ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></p><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul></blockquote><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length, max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((length = nums.length) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用dp数组来保存每个元素前面面最长严格递增子序列的长度</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始长度为1</span></span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="comment">// 更新dp[i]的值</span></span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新返回结果</span></span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></p><blockquote><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol></blockquote><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将区间[left, right]分为两段</span></span><br><span class="line">        <span class="comment">// 其中左边为[left, mid]</span></span><br><span class="line">        <span class="comment">// 右边为[mid + 1, right]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// target大于中间值</span></span><br><span class="line">                <span class="comment">// 则缩小左边的范围</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则缩小右边的范围</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后退出while循环时，left会等于right</span></span><br><span class="line">        <span class="comment">// 此时如果nums[left] == target则返回left</span></span><br><span class="line">        <span class="comment">// 否则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>难度：<mark class="hl-label red">困难</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></p><blockquote><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul></blockquote><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">if</span> ((length = height.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个柱子能接多少雨水等于当前柱子两边最大高度的较小值减去当前高度的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, left, right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            left = right = height[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到左边最大最大高度的柱子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                left = Math.max(left, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到右边最大最大高度的柱子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                right = Math.max(right, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前柱子两边最大高度的较小值减去当前高度的值</span></span><br><span class="line">            <span class="comment">// 就是当前柱子能接的雨水</span></span><br><span class="line">            sum += Math.min(left, right) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大厂面试 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> CodeTop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大厂面试力扣算法题———CodeTop题解（二）</title>
      <link href="/10030/"/>
      <url>/10030/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://codetop.cc/">CodeTop</a> 用于汇总互联网大厂面试的高频考题帮助面试者更有针对性地准备面试。</p><p>《大厂面试力扣算法题———CodeTop题解》系列文章将致力于为 <a href="https://codetop.cc/">CodeTop</a> 中的前 100 道在大厂面试当中会高频出现的算法题写题解，希望能给将要或者正在找工作的同学提供参考，如果有帮助到你，那将是我的荣幸~</p><p>为了缩小篇幅，《大厂面试力扣算法题———CodeTop题解》系列文章将分成 10 篇文章持续推出，每篇文章将会有 10 道题目的题解。因为 <a href="https://codetop.cc/">CodeTop</a> 上的题目顺序是随着题目的热度一直在变动的，所以题解的顺序可能会和 <a href="https://codetop.cc/">CodeTop</a> 顺序不一致，特此说明。</p><p>那么接下来，让我们进入正题吧~</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></p><blockquote><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul></blockquote><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用快慢指针来判断链表中是否有环</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 慢指针跳一个节点</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 快指针跳两个节点</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有环，快慢指针最终会相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="comment">// 直接返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用队列实现层序遍历</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.addFirst(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 因为每一层都需要放在一个集合中</span></span><br><span class="line">            <span class="comment">// 所以这里先把同一层的节点放到list中</span></span><br><span class="line">            List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 遍历队列</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 将队列中的元素放入list中</span></span><br><span class="line">                <span class="comment">// 这里就是将同一层到节点放入到list中</span></span><br><span class="line">                list.add(queue.removeLast());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 然后再遍历这一层的节点</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : list) &#123;</span><br><span class="line">                <span class="comment">// 当前节点值放入nums集合中</span></span><br><span class="line">                nums.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前节点左节点不为空</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 就将左节点放入队列中</span></span><br><span class="line">                    queue.addFirst(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前节点右节点不为空</span></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 就将右节点放入队列中</span></span><br><span class="line">                    queue.addFirst(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前层的结果放入res中</span></span><br><span class="line">            res.add(nums);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></p><blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul></blockquote><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// 贪心算法，min为数组中最小的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> prices.length, res = <span class="number">0</span>, min = prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过遍历数组找到最小的元素</span></span><br><span class="line">        <span class="comment">// 然后和后面的元素相减得出的差中取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新最小值</span></span><br><span class="line">            <span class="keyword">if</span> (min &gt; prices[i]) &#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 和后面的元素相减并与res取最大值</span></span><br><span class="line">            res = Math.max(res, prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></p><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用栈实现层序遍历</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// true：表示从左往右</span></span><br><span class="line">        <span class="comment">// false：表示从右往左</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 因为每一层都需要放在一个集合中</span></span><br><span class="line">            <span class="comment">// 所以这里先把同一层的节点放到list中</span></span><br><span class="line">            List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 遍历队列</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 将栈中的元素放入list中</span></span><br><span class="line">                <span class="comment">// 这里就是将同一层到节点放入到list中</span></span><br><span class="line">                list.add(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 然后再遍历这一层的节点</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : list) &#123;</span><br><span class="line">                <span class="comment">// 当前节点值放入nums集合中</span></span><br><span class="line">                nums.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (flag) &#123; <span class="comment">// 如果当前是从左往右</span></span><br><span class="line">                    <span class="comment">// 则先将left入栈</span></span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 再将right入栈</span></span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前是从右往左</span></span><br><span class="line">                    <span class="comment">// 则先将right入栈</span></span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 再将left入栈</span></span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 变换方向</span></span><br><span class="line">            flag = !flag;</span><br><span class="line">            <span class="comment">// 将当前层的结果放入res中</span></span><br><span class="line">            res.add(nums);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="/img/backend/10030_01.png" alt="img"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>自定义评测：</p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li><li>listA - 第一个链表</li><li>listB - 第二个链表</li><li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</li><li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</li><li>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</li></ul><p>提示：</p><ul><li>listA 中节点数目为 m</li><li>listB 中节点数目为 n</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 3 * 104</li><li>1 &lt;&#x3D; Node.val &lt;&#x3D; 105</li><li>0 &lt;&#x3D; skipA &lt;&#x3D; m</li><li>0 &lt;&#x3D; skipB &lt;&#x3D; n</li><li>如果 listA 和 listB 没有交点，intersectVal 为 0</li><li>如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA] &#x3D;&#x3D; listB[skipB]</li></ul></blockquote><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果headA或者headB其中一个为null</span></span><br><span class="line">        <span class="comment">// 那么它们必然不会相交，所以直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用Set集合保存headA链表的所有节点</span></span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="comment">// 遍历headA将节点放入set集合中</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            set.add(node);</span><br><span class="line"></span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = headB;</span><br><span class="line">        <span class="comment">// 再遍历headB</span></span><br><span class="line">        <span class="comment">// 并判断headB中是否有和set中相同的节点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果有相同的节点</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(node)) &#123;</span><br><span class="line">                <span class="comment">// 那么第一个相同的节点就是相交节点</span></span><br><span class="line">                <span class="comment">// 直接返回</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳到下一个节点</span></span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></p><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul></blockquote><h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (length % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用栈来完成括号匹配</span></span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历字符串的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符是左括号</span></span><br><span class="line">                <span class="comment">// 则则直接入栈</span></span><br><span class="line">                stack.push(c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果遇到右括号，但是栈是空</span></span><br><span class="line">            <span class="comment">// 说明当前字符前面没有与之匹配的左括号</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 否则弹出栈顶元素</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">l</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c != <span class="string">&#x27;)&#x27;</span> || l == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c != <span class="string">&#x27;&#125;&#x27;</span> || l == <span class="string">&#x27;[&#x27;</span> &amp;&amp; c != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果栈顶元素不能和当前字符匹配成功</span></span><br><span class="line">                <span class="comment">// 则直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈不为空表示还有括号没有匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 这里直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到了这里表示所有括号都匹配成功，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>提示：</p><ul><li>树中节点数目在范围 [2, 105] 内。</li><li>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109</li><li>所有 Node.val 互不相同 。</li><li>p !&#x3D; q</li><li>p 和 q 均存在于给定的二叉树中。</li></ul></blockquote><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 先序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要遇到了p或者q</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="comment">// 则直接返回一个不为空的节点</span></span><br><span class="line">            <span class="comment">// 这里返回root节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后先遍历左节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">// 再遍历右节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遍历左右节点返回的结果都不为空</span></span><br><span class="line">        <span class="comment">// 则表示当前root节点就是p和q的最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接返回root</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则返回遍历左右节点不为空的结果</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></p><blockquote><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p>提示：</p><ul><li>nums1.length &#x3D;&#x3D; m + n</li><li>nums2.length &#x3D;&#x3D; n</li><li>0 &lt;&#x3D; m, n &lt;&#x3D; 200</li><li>1 &lt;&#x3D; m + n &lt;&#x3D; 200</li><li>-109 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 109</li></ul></blockquote><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 先用临时数组temp将nums1数组中的元素保存起来</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            temp[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 合并数组temp和nums2</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; m || j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                <span class="comment">// 如果temp遍历完了，那么直接将nums2[j]合入nums1</span></span><br><span class="line">                nums1[k] = nums2[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                <span class="comment">// 如果nums2遍历完了，那么直接将temp[i]合入nums1</span></span><br><span class="line">                nums1[k] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt; nums2[j]) &#123;</span><br><span class="line">                <span class="comment">// 如果temp[i]更小就将temp[i]合入nums1</span></span><br><span class="line">                nums1[k] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则nums2[j]更小就将nums2[j]合入nums1</span></span><br><span class="line">                nums1[k] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p><blockquote><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000</li><li>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4</li><li>nums 中的每个值都 独一无二</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</li></ul></blockquote><h3 id="二分法变种"><a href="#二分法变种" class="headerlink" title="二分法变种"></a>二分法变种</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length, left = <span class="number">0</span>, right = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二分法变种</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果nums[mid] == target</span></span><br><span class="line">            <span class="comment">// 找到到了target</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="comment">// 直接返回mid</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果nums[left] &lt;= nums[mid]</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 表示区间[left, mid]是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    <span class="comment">// 表示targer在区间[left, mid]内</span></span><br><span class="line">                    <span class="comment">// 所以收缩right，mid - 1</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则表示targer不在区间[left, mid]内</span></span><br><span class="line">                    <span class="comment">// 收缩left，mid + 1</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则表示区间[mid, right]是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    <span class="comment">// 表示target在区间[mid, right]内</span></span><br><span class="line">                    <span class="comment">// 所以收缩left，mid + 1</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则表示targer不在区间[mid, right]内</span></span><br><span class="line">                    <span class="comment">// 收缩right，mid - 1</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到了这里表示没有找到target</span></span><br><span class="line">        <span class="comment">// 返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></p><blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul></blockquote><h3 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length(), st = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串找出最长的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 先以位置i为中心向两边统计回文子串的长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> helper(s, i, i);</span><br><span class="line">            <span class="comment">// 再以位置i和下一个位置i + 1为中心向两边统计回文子串的长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> helper(s, i, i + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 取两者中的最大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(s1, s2);</span><br><span class="line">            <span class="comment">// 如果最大值大于现有的回文子串长度</span></span><br><span class="line">            <span class="keyword">if</span> (max &gt; end - st + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 则更新st和end</span></span><br><span class="line">                <span class="comment">// 如果max为奇数，则i为中心位置</span></span><br><span class="line">                <span class="comment">// 如果max为偶数，则i为中心位置中左边的位置</span></span><br><span class="line">                <span class="comment">// 所以计算st时要减去(max - 1) / 2</span></span><br><span class="line">                st = i - (max - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 计算end时直接加上max的一半即max / 2</span></span><br><span class="line">                end = i + max / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(st, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计字符串在left和right位置两边回文子串的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; length &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大厂面试 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> CodeTop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大厂面试力扣算法题———CodeTop题解（一）</title>
      <link href="/10029/"/>
      <url>/10029/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://codetop.cc/">CodeTop</a> 用于汇总互联网大厂面试的高频考题帮助面试者更有针对性地准备面试。</p><p>《大厂面试力扣算法题———CodeTop题解》系列文章将致力于为 <a href="https://codetop.cc/">CodeTop</a> 中的前 100 道在大厂面试当中会高频出现的算法题写题解，希望能给将要或者正在找工作的同学提供参考，如果有帮助到你，那将是我的荣幸~</p><p>为了缩小篇幅，《大厂面试力扣算法题———CodeTop题解》系列文章将分成 10 篇文章持续推出，每篇文章将会有 10 道题目的题解。因为 <a href="https://codetop.cc/">CodeTop</a> 上的题目顺序是随着题目的热度一直在变动的，所以题解的顺序可能会和 <a href="https://codetop.cc/">CodeTop</a> 顺序不一致，特此说明。</p><p>那么接下来，让我们进入正题吧~</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list">206. 反转链表</a></p><blockquote><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul></blockquote><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建newHead作为新链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 临时节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 开始迭代</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> node;</span><br><span class="line">            <span class="comment">// 临时节点指向下一个节点</span></span><br><span class="line">            node = node.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让当前节点指向newHead的next节点</span></span><br><span class="line">            cur.next = newHead.next;</span><br><span class="line">            <span class="comment">// newHead的next节点指向当前节点</span></span><br><span class="line">            <span class="comment">// 这样就把当前节点拼到了前继节点的前面</span></span><br><span class="line">            newHead.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新链表</span></span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 先要递归到底</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">// 递归到底返回的节点就是新链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> reverseList(next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点指向null</span></span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// next节点指向当前节点</span></span><br><span class="line">        next.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新链表的头节点node节点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><blockquote><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul></blockquote><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || (length = s.length()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left、right作为滑动窗口的左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// windows保存left和right之间滑动窗口每个字符出现的次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; windows = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 遍历字符串s</span></span><br><span class="line">            <span class="comment">// 每次遍历结束都保证滑动窗口的字符是不重复的</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right++);</span><br><span class="line">            <span class="comment">// 记录字符c出现一次</span></span><br><span class="line">            windows.put(c, windows.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果字符出现次数大于1</span></span><br><span class="line">            <span class="comment">// 说明字符c重复了</span></span><br><span class="line">            <span class="keyword">while</span> (windows.get(c) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 这个时候缩小滑动窗口的范围</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> s.charAt(left++);</span><br><span class="line">                <span class="comment">// t已经不在滑动窗口里面了</span></span><br><span class="line">                <span class="comment">// 所以要减去</span></span><br><span class="line">                windows.put(t, windows.get(t) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再重新计算滑动窗口内的长度</span></span><br><span class="line">            <span class="comment">// 和res取最大值更新结果res</span></span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></p><blockquote><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p>提示：</p><p>1 &lt;&#x3D; capacity &lt;&#x3D; 3000<br>0 &lt;&#x3D; key &lt;&#x3D; 10000<br>0 &lt;&#x3D; value &lt;&#x3D; 105<br>最多调用 2 * 105 次 get 和 put</p></blockquote><h3 id="链表-哈希"><a href="#链表-哈希" class="headerlink" title="链表+哈希"></a>链表+哈希</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">// memory维护key和Node的关系</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; memory;</span><br><span class="line">    <span class="comment">// 利用链表维护最近最久未使用的Node</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Node&gt; linkedList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node用来保存key和value的关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.memory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// key不存在就返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (!memory.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key存在获取对应Node</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> memory.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Node调整到链表的最前面</span></span><br><span class="line">        linkedList.remove(node);</span><br><span class="line">        linkedList.addFirst(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// key已经存在</span></span><br><span class="line">        <span class="keyword">if</span> (memory.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 获取对应Node</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> memory.get(key);</span><br><span class="line">            <span class="comment">// 更新value</span></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Node调整到链表的最前面</span></span><br><span class="line">            linkedList.remove(node);</span><br><span class="line">            linkedList.addFirst(node);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (memory.size() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 就删除最后一个Node</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> linkedList.removeLast();</span><br><span class="line">            memory.remove(node.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新的key和value放到链表的最前面</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">        linkedList.addFirst(node);</span><br><span class="line">        memory.put(key, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul></blockquote><h3 id="API排序"><a href="#API排序" class="headerlink" title="API排序"></a>API排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 先对数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取倒数第k个数就是第 k 个最大的元素</span></span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h2><p>难度：<mark class="hl-label red">困难</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></p><blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>提示：</strong></p><ul><li>列表中节点的数量在范围 <code>sz</code> 内</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ul></blockquote><h3 id="分割法"><a href="#分割法" class="headerlink" title="分割法"></a>分割法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先将链表按k个节点进行分割</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; ++i &lt; k) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果剩余链表长度小于k</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">            <span class="comment">// 就直接返回头节点head</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转当前段的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseListNode(head);</span><br><span class="line">        <span class="comment">// 然后继续递归反转剩余的链表</span></span><br><span class="line">        head.next = reverseKGroup(next, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseListNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> reverseListNode(next);</span><br><span class="line"></span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        next.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><blockquote><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li><li><code>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></li></ul></blockquote><h3 id="双路快排"><a href="#双路快排" class="headerlink" title="双路快排"></a>双路快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        helper(nums, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双路快排</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> l, gt = r + <span class="number">1</span>, i = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; e) &#123;</span><br><span class="line">                swap(nums, ++lt, i++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; e) &#123;</span><br><span class="line">                swap(nums, --gt, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(nums, l, lt);</span><br><span class="line"></span><br><span class="line">        helper(nums, l, lt - <span class="number">1</span>);</span><br><span class="line">        helper(nums, gt, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组中两个位置的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// heapify：构建一个最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            shiftDown(nums, length, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原地堆排序</span></span><br><span class="line">        <span class="comment">// 将最大堆堆顶元素nums[0]与堆中最后一个叶子节点元素nums[i]交换位置</span></span><br><span class="line">        <span class="comment">// 然后通过shiftDown维护区间[0, i)范围内最大堆的性质</span></span><br><span class="line">        <span class="comment">// 直到只剩下根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 交换堆顶与最后一个叶子的位置</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 维护区间[0, i)范围内最大堆的性质</span></span><br><span class="line">            shiftDown(nums, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将以nums[k]为根节点</span></span><br><span class="line"><span class="comment">     * 且在区间[0, length)范围内的子树构建成最大堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shiftDown</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> length, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// nums[2 * k + 1]表示根节点num[k]的左节点</span></span><br><span class="line">        <span class="comment">// nums[2 * k + 2]表示根节点num[k]的右节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt; length) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 取根节点nums[i]左右节点中较大的节点</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; nums[j] &lt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果根节点比左右节点中较大的节点还大</span></span><br><span class="line">            <span class="comment">// 说明当前以nums[k]为根节点的树已经是最大堆</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="comment">// 直接break退出循环</span></span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换nums[k]与nums[j]</span></span><br><span class="line">            <span class="comment">// 以维护最大堆的性质</span></span><br><span class="line">            swap(nums, k, j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后切换根节点为nums[j]</span></span><br><span class="line">            <span class="comment">// 继续维护nums[k]的子树为最大堆</span></span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组中i和j两个元素的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h3 id="排序-左右指针"><a href="#排序-左右指针" class="headerlink" title="排序+左右指针"></a>排序+左右指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">if</span> ((length = nums.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先对数组nums进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第一个元素开始</span></span><br><span class="line">        <span class="comment">// 将当前元素和后面元素一头一尾相加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// l和r之间形成一个区间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i + <span class="number">1</span>, r = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果结果等于0</span></span><br><span class="line">                    <span class="comment">// 则记录结果</span></span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[l]);</span><br><span class="line">                    list.add(nums[r]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 并将结果加入res</span></span><br><span class="line">                    res.add(list);</span><br><span class="line"></span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从左边跳过重复的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l - <span class="number">1</span>] == nums[l]) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从右边跳过重复的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]) &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// num小于0说明左边太小</span></span><br><span class="line">                    <span class="comment">// l向右移动</span></span><br><span class="line">                    l++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// num大于0说明左边太大</span></span><br><span class="line">                    <span class="comment">// r向左移动</span></span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>难度：<mark class="hl-label orange">中等</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></p><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul></blockquote><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// max记录最大值</span></span><br><span class="line">        <span class="comment">// pre记录连续子数组的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>], pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 更新连续子数组的和</span></span><br><span class="line">            pre = Math.max(pre + num, num);</span><br><span class="line">            <span class="comment">// 再更新max</span></span><br><span class="line">            max = Math.max(pre, max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></p><blockquote><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案</p></blockquote><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用HashMap保存元素与下标的关系</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; memory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> target - num;</span><br><span class="line">            <span class="keyword">if</span> (memory.containsKey(x)) &#123;</span><br><span class="line">                <span class="comment">// 如果x存在于memory中</span></span><br><span class="line">                <span class="comment">// 直接返回i和x对应的数组下标</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, memory.get(x)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存元素和下标的关系</span></span><br><span class="line">            memory.put(num, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p>难度：<mark class="hl-label green">简单</mark> </p><p>原题链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul></blockquote><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span> &amp;&amp; list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个head节点作为合并后链表到头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">// node作为活动节点，用来合并节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> || list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果list1为空，那么直接将list2合入node.next</span></span><br><span class="line">                node.next = list2;</span><br><span class="line">                <span class="comment">// 然后直接break</span></span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果list2为空，那么直接将list1合入node.next</span></span><br><span class="line">                node.next = list1;</span><br><span class="line">                <span class="comment">// 然后直接break</span></span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                <span class="comment">// list1.val更小，就将list1合入node.next</span></span><br><span class="line">                node.next = list1;</span><br><span class="line">                <span class="comment">// list1跳到下一个节点</span></span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// list2.val更小，就将list2合入node.next</span></span><br><span class="line">                node.next = list2;</span><br><span class="line">                <span class="comment">// list2跳到下一个节点</span></span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// node跳到下一个节点</span></span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回头节点到next即新链表到头节点</span></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大厂面试 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> CodeTop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring整体架构</title>
      <link href="/10028/"/>
      <url>/10028/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spring是于2003年兴起的一个轻量级的Java开源框架，由Rod Johnson在其著作《Expert One-On-One J2EE Development and Design》中阐述的部分理念和原型衍生而来。</p></blockquote><p>Spring框架是一个分层架构，它包含一系列的功能要素，并被分为大约20个模块，这些模块被总结为以下几部分。</p><p><img src="/img/backend/10028/10028_01.png" alt="Spring整体架构"></p><h2 id="1-Core-Container"><a href="#1-Core-Container" class="headerlink" title="1.Core Container"></a>1.Core Container</h2><p>CoreContainer（核心容器）包含有Core、Beans、Context和Expression Language模块。Core和Beans模块是框架的基础部分，提供IoC（转控制）和依赖注入特性。</p><ul><li><p>Core模块主要包含Spring框架基本的核心工具类，Spring的其他组件要都要使用到这个包里的类，Core模块是其他组件的基本核心。</p></li><li><p>Beans模块是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control&#x2F;Dependency Injection（IoC&#x2F;DI）操作相关的所有类。</p></li><li><p>Context模块构建于Core和Beans模块基础之上，提供了一种类似于JNDI注册器的框架式的对象访问方法。Context模模块继承了Beans的特性，为Spring核心提供了大量扩展，添加了对国际化（例如资源绑定）、事件传播、资源加载和对Context的透明创建的支持。</p></li><li><p>Expression Language模块提供了一个强大的表达式语言用于在运行时查询和操纵对象。</p></li></ul><h2 id="2-Data-Access-x2F-Integration"><a href="#2-Data-Access-x2F-Integration" class="headerlink" title="2.Data Access&#x2F;Integration"></a>2.Data Access&#x2F;Integration</h2><p>DataAccess&#x2F;Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块</p><ul><li><p>JDBC模块提供了一个JDBC抽象层，它可以消除冗长的JDBC编码和解析数据库厂商特有的错误代码。这个模块包含了Spring对JDBC数据访问进行封装的所有类。</p></li><li><p>ORM模块为流行的对象-关系映射API，如JPA、JDO、Hibernate、iBatis等，提供了一个交互层。利用ORM封装包，可以混合使用所有Spring提供的特性进行O&#x2F;R映射。如前边提到的简单声明性事物管理。Spring框架插入了若干个ORM框架，从而提供了ORM的对象关系工具，其中包括JDO、Hibernate和iBatisSQL Map。所有这些都遵从Spring的通用事务和DAO异常层次结构。</p></li><li><p>OXM模块提供了一个对Object&#x2F;XML映射实现的抽象层，Object&#x2F;XML映射实现包括JAXB、Castor、XMLBeans、JiBXJiBX和XStream。</p></li><li><p>JMS（Java Messaging Service）模块主要包含了一些制造和消费消息的特性。</p></li><li><p>Transaction模块支持编程和声明性的事物管理，这些事物类必须实现特定的接口，并且对所有的POJO都适用。</p></li></ul><h2 id="3-Web"><a href="#3-Web" class="headerlink" title="3.Web"></a>3.Web</h2><p>Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。</p><ul><li><p>Web模块：提供了基础的面向Web的集成特性。例如，多文件上传、使用servlet listeners初始化IoC容器以及一个面向Web的应用上下文。它还包含Spring远程支持中Web的相关部分。</p></li><li><p>Web-Servlet模块web.servlet.jar：该模块包含Spring的model-view-controller（MVC）实现。Spring的MVC框架使得模型范围内的代码和web forms之间能够清楚地分离开来，并与Spring框架的其他特性集成在一起。</p></li><li><p>Web-Struts模块：该模块提供了对Struts的支持，使得类在Spring应用中能够与一个典型的Struts Web层集成在一起。注意，该支持在Spring3.0中是deprecated的。</p></li><li><p>Web-Porlet模块：提供了用于Portlet环境和Web-Servlet模块的MVC的实现。</p></li></ul><h2 id="4-AOP"><a href="#4-AOP" class="headerlink" title="4.AOP"></a>4.AOP</h2><p>AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现，它让你可以定义例如方法拦截器和切点，从而将逻辑代代码分开，降低它们之间的耦合性。</p><p>通过配置管理特性，Spring AOP模块直接将面向切面的编程功能集成到了Spring框架中，所以可以很容易地使Spring框架管理的任何对象支持AOP。Spring AOP模块为基于Spring的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，不用依赖EJB组件，就可以将声明性事务管理集成到应用程序中。</p><ul><li><p>Aspects模块提供了对AspectJ的集成支持。</p></li><li><p>Instrumentation模块提供了class instrumentation支持和classloader实现，使得可以在特定的应用服务器上使用。</p></li></ul><h2 id="5-Test"><a href="#5-Test" class="headerlink" title="5.Test"></a>5.Test</h2><p>Test模块支持使用JUnit和TestNG对Spring组件进行测试。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码分析之——Condition</title>
      <link href="/10027/"/>
      <url>/10027/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition。</p><p>Condition能实现synchronized和wait、notify搭配的功能，另外比后者更灵活，Condition可以实现多路通知功能，也就是在一个Lock对象里可以创建多个Condition（即对象监视器）实例，线程对象可以注册在指定的Condition中，从而可以有选择的进行线程通知，在调度线程上更加灵活。而synchronized就相当于整个Lock对象中只有一个单一的Condition对象，所有的线程都注册在这个对象上。线程开始notifyAll时，需要通知所有的WAITING线程，没有选择权，会有相当大的效率问题。</p><p>这里要讲的是ReentrantLock（不了解ReentrantLock的同学可以看一下<a href="https://silentao.com/2020/05/29/10026/">JDK源码分析之——ReentrantLock</a>）中的Condition，Condition是一个接口，而ReentrantLock里使用的Condition是由AQS（AbstractQueuedSynchronizer，这里又要回到AQS了哈哈，不了解AQS的同学可以看看之前发布的<a href="https://silentao.com/2019/04/08/10016/">JDK源码分析之——AQS</a>）的内部类ConditionObject实现的。在ConditionObject内部维护了一个由Node（AQS里的另一个类）节点连接而成的等待队列，这个队列是一个单链表，同时ConditionObject还有指向单链表首尾节点的指针，方便对整个队列进行遍历。</p><p>流程图如下：<br><img src="/img/backend/10027/10027_1.png" alt="Condition流程图"></p><p>由于鄙人不善于作图，所以接下来会有大量的源码注释还有文字说明，如果有说得不清楚的地方，还望评论区指出哈</p><h2 id="1-ConditionObject的成员变量"><a href="#1-ConditionObject的成员变量" class="headerlink" title="1.ConditionObject的成员变量"></a>1.ConditionObject的成员变量</h2><p>ConditionObject的成员变量比较简单，包含两个分别指向队列头尾的指针和两种等待退出的模式，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向队列的头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向队列的尾指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在等待退出时重新标记中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在等待退出时抛出中断异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-await"><a href="#2-await" class="headerlink" title="2.await"></a>2.await</h2><p>await方法的作用就是释放当前线程持有的锁，然后将当前线程挂起，直到有其它线程将它唤醒或者被中断。在源码讲解前，先来做个名称解释：</p><ul><li>同步队列：指的是在AQS中等待获取资源的队列，由AQS控制；</li><li>等待队列：指的是调用await方法之后等待被signal唤醒的队列，由AQS内部类ConditionObject控制。</li></ul><p>await方法具体流程如下：</p><ol><li>如果线程被中断，直接抛出中断异常；</li><li>创建一个状态为CONDITION的Node节点，并将节点放在等待队列的队尾；</li><li>完全释放线程占有的全部资源；</li><li>循环判断Node节点是否不在同步队列中，然后将当前线程挂起，否则退出循环，如果线程被中断也会退出循环；</li><li>尝试去同步队列中获取所需要的资源，如果暂时拿不到就挂起当前线程，直到当前节点变成同步队列的第二个节点时被唤醒；</li><li>如果当前节点在等待队列中还有后继节点，说明当前线程是被中断唤醒的，这个时候要把等待队列中不是CONDITION状态的节点清理掉；</li><li>根据interruptMode的值来决定是否需要抛出中断异常或者重新标记中断。</li></ol><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">// 如果线程被中断过，就直接抛出中断异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 创建一个状态为CONDITION的Node节点，并将节点放在等待队列的队尾</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 完全释放线程占有的全部资源</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="comment">// 标记线程最后退出的模式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// node节点不在同步队列中（指的是AQS的同步队列）</span></span><br><span class="line">        <span class="comment">// 当前线程被其它线程唤醒时</span></span><br><span class="line">        <span class="comment">// node节点就会被加入到同步队列的队尾，这时自然会退出循环</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挂起当前线程</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果线程被中断，直接退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试去同步队列中获取所需要的资源（这个方法在讲AQS的文章里讲过，这里不再复述）</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">// 如果线程在获取资源时被中断并且不是以抛异常的形式退出</span></span><br><span class="line">        <span class="comment">// 那就将退出模式置为为重新标记中断</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        <span class="comment">// 当前节点在等待队列中还有后继节点</span></span><br><span class="line">        <span class="comment">// 说明当前线程是被中断唤醒的</span></span><br><span class="line">        <span class="comment">// 被正常唤醒的节点的后继节点会被置为null且会被放在同步队列的队尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把等待队列中不是CONDITION状态的节点清理掉    </span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 表示非正常唤醒（因中断被唤醒）</span></span><br><span class="line">        <span class="comment">// 那就根据interruptMode标记的值来决定是抛出异常还是重新标记中断</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-addConditionWaiter"><a href="#2-1-addConditionWaiter" class="headerlink" title="2.1 addConditionWaiter"></a>2.1 addConditionWaiter</h3><p>addConditionWaiter方法用来创建一个状态为CONDITION的新Node节点，并添加等待队列尾部，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 清理状态不是CONDITION节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 再次获取尾节点</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个状态为CONDITION的新Node节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新节点添加到等待队列尾部</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-fullyRelease"><a href="#2-2-fullyRelease" class="headerlink" title="2.2 fullyRelease"></a>2.2 fullyRelease</h3><p>fullyRelease方法的作用是释放线程持有的所有的资源，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放线程持有的所有资源（该方法是QAS的方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 用来标记过程是否是失败</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程占用的所有资源</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            <span class="comment">// 成功释放资源</span></span><br><span class="line">            <span class="comment">// 将失败标记置为false</span></span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 返回释放的资源</span></span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源失败则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 资源释放失败就将当前节点标记为CANCELLED（取消状态）</span></span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-isOnSyncQueue"><a href="#2-3-isOnSyncQueue" class="headerlink" title="2.3 isOnSyncQueue"></a>2.3 isOnSyncQueue</h3><p>isOnSyncQueue方法是用来判断node节点是否在同步队列，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * node节点是否在同步队列中（该方法是QAS的方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 如果节点状态为CONDITION</span></span><br><span class="line">        <span class="comment">// 或者node节点的前继节点为空，那么node肯定不在同步队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有两种情况node节点的前继节点会为空</span></span><br><span class="line">        <span class="comment">// 1.node节点不在同步队列里；</span></span><br><span class="line">        <span class="comment">// 2.node节点是同步队列的头结点。</span></span><br><span class="line">        <span class="comment">// 很显然这里不会是同步队列的头结点</span></span><br><span class="line">        <span class="comment">// 因为同步队列头结点的是持有资源的线程对应的节点</span></span><br><span class="line">        <span class="comment">// 如果持有资源的线程调用await方法到这里的node</span></span><br><span class="line">        <span class="comment">// 已经不是同步队列头结点的那个node了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果node有后继节点，那么肯定是在同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node的前继节点为非空，并不意味着node就在同步队列中</span></span><br><span class="line">    <span class="comment">// 因为CAS操作在将node节点加入到同步队列时可能失败</span></span><br><span class="line">    <span class="comment">// 所以我们必须确保node节点已经在同步队列中</span></span><br><span class="line">    <span class="comment">// 那么就需要从同步队列的尾部遍历</span></span><br><span class="line">    <span class="comment">// 看node节点是否在同步队列中</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从同步队列尾部遍历看node节点是否在同步队列中（该方法是QAS的私有方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取同步队列的尾部节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="comment">// 节点在同步队列中，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-checkInterruptWhileWaiting"><a href="#2-4-checkInterruptWhileWaiting" class="headerlink" title="2.4 checkInterruptWhileWaiting"></a>2.4 checkInterruptWhileWaiting</h3><p>checkInterruptWhileWaiting方法主要是校验node节点对应的线程是否被中断唤醒，如果是在被signal唤醒之前被中断就返回THROW_IE（表示在退出时要抛出中断异常），如果是在被signal唤醒之后被中断则返回REINTERRUPT（表示在退出时要重新标记中断），如果是被signal唤醒没有被中断则返回0（表示线程整个挂起的过程中都没有被中断），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断中断发生的时机（该方法是QAS的私有方法）</span></span><br><span class="line"><span class="comment"> * 返回true：表示在被signal唤醒之前被中断</span></span><br><span class="line"><span class="comment"> * 返回false：表示在被signal唤醒之后被中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 通过CAS将node节点的状态修改为0</span></span><br><span class="line">        <span class="comment">// 成功表示此时node节点还在等待队列中</span></span><br><span class="line">        <span class="comment">// 间接表明此时的node节点是被中断唤醒的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将node节点加入到同步队列尾部</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到了这里说明中断是在被signal唤醒之后发生的</span></span><br><span class="line">    <span class="comment">// 此时我们需要保证node节点已经在同步队列中</span></span><br><span class="line">    <span class="comment">// 才能继续往下执行</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        <span class="comment">// 如果node不在同步队列中，那么调用线程让步</span></span><br><span class="line">        <span class="comment">// 直到node节点已经在同步队列中为止</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-unlinkCancelledWaiters"><a href="#2-5-unlinkCancelledWaiters" class="headerlink" title="2.5 unlinkCancelledWaiters"></a>2.5 unlinkCancelledWaiters</h3><p>unlinkCancelledWaiters方法的作用是删除等待队列中不是CONDITION状态的节点，从头开始挨个遍历每个节点，删除状态不是CONDITION状态的节点，也就是单链表的节点删除操作，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从等待队列中删除状态不是CONDITION状态的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取头节点，从头节点开始遍历</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点状态不是CONDITION就从链表中删除</span></span><br><span class="line">            t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// next为空表示当前节点是最后一个节点</span></span><br><span class="line">            <span class="comment">// 将尾节点指针指向next</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-reportInterruptAfterWait"><a href="#2-6-reportInterruptAfterWait" class="headerlink" title="2.6 reportInterruptAfterWait"></a>2.6 reportInterruptAfterWait</h3><p>reportInterruptAfterWait方法控制线程退出时是抛出中断异常还是重新标记中断，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * interruptMode == THROW_IE：抛出中断异常</span></span><br><span class="line"><span class="comment"> * interruptMode == REINTERRUPT：重新标记中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="comment">// 抛出中断异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        <span class="comment">// 重新标记中断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h3><p>await方法的源码分析在这里就告一段落啦，其中还有不响应中断的awaitUninterruptibly方法，带超时的awaitNanos和await方法以及指定超时截止时间的awaitUntil方法，逻辑大致和上面的await方法如出一辙，这里就不一一叙述啦，刚兴趣的同学可以自行研究。await方法会将线程占有的所有资源都释放掉，然后将线程挂起直到其它线程将它唤醒或者被中断。期间涉及到了node节点从等待队列到同步队列的转移，然后线程在同步队列中重新获取资源（即重新获得锁）后继续执行的整个过程。虽然过程不是很复杂，但是同时调用了内部类ConditionObject和AQS的方法，还需仔细品味等待队列和同步队列之间的关系，才能明白它们的巧妙之处。加油鸭！</p><h2 id="3-signal"><a href="#3-signal" class="headerlink" title="3.signal"></a>3.signal</h2><p>signal方法主要是将等待队列中等待最久的那个没有取消的node节点转移到同步队列中的尾部，使该node节点有在同步队列中等待获取资源（获得锁）的资格，得以继续执行await方法后面的逻辑。具体过程如下：</p><ol><li>判断当前线程是否为持有锁的线程，如果不是则抛出IllegalMonitorStateException异常；</li><li>获取等待队列中头结点，然后将头结点指针指向头结点的下一个节点，然后尝试将当前结点转移到同步队列的尾部；</li><li>如果当前节点在同步队列的前继节点已经取消或者修改其前继节点状态为SIGNAL失败时，换醒当前节点；</li><li>如果上述操作失败就重复2、3过程，直到成功将一个节点转移到同步队列，或者遍历完等待队列就结束整个过程。</li></ol><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试唤醒等待队列中等待了最近的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="comment">// 如果当前线程不是持有锁的线程</span></span><br><span class="line">        <span class="comment">// 抛出IllegalMonitorStateException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取等待队列的头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 头结点不为空，开始尝试唤醒头结点</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-doSignal"><a href="#3-1-doSignal" class="headerlink" title="3.1 doSignal"></a>3.1 doSignal</h3><p>doSignal主要是从等待队列头部开始遍历，然后将节点从等待队列中移除，并尝试将节点转移到同步队列中，直到有一个成功或者遍历完整个等待队列为止，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历等待队列并将相应节点从等待队列中移除</span></span><br><span class="line"><span class="comment"> * 然后尝试将节点转移到同步队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 将头部指针指向first.nextWaiter</span></span><br><span class="line">        <span class="comment">// 这里是要讲first节点删除掉</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// first.nextWaiter为空表示整个等待队列已经空了</span></span><br><span class="line">            <span class="comment">// 将等待队列尾部指针也置为空</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// first.nextWaiter置为空</span></span><br><span class="line">        <span class="comment">// 彻底将first断开</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试将first节点转移到同步队列中，有一次成功就退出循环</span></span><br><span class="line">        <span class="comment">// 或者遍历完整个等待队列时再退出</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将node节点转移到同步队列的尾部（该方法是QAS的方法）</span></span><br><span class="line"><span class="comment"> * 返回true表示成功转移</span></span><br><span class="line"><span class="comment"> * 返回false表示node可能已经取消或者已经转移过了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试将node节点状态修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// 修改失败可能node节点已经取消了或者已经转移到同步队列里了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将node节点转移到同步队列尾部并返回它的前继节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="comment">// 获取前继节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="comment">// 这一步应该是为了保证node节点的前继节点为SIGNAL状态</span></span><br><span class="line">    <span class="comment">// 好在前继执行完成时可以顺利唤醒node节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前继节点状态为取消</span></span><br><span class="line">        <span class="comment">// 或者修改前继节点状态为SIGNAL失败</span></span><br><span class="line">        <span class="comment">// 就唤醒node节点对应的线程</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node节点转移成功，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-小结"><a href="#3-2-小结" class="headerlink" title="3.2 小结"></a>3.2 小结</h3><p>signal方法主要是将在等待队列中等待了最久的且没有取消的一个节点转移到同步队列中，以便节点可以在同步队列中有再次获取资源的资格，可以继续完成后面的事情。而signalAll方法和signal方法唯一不同的是，signalAll方法是要将所有等待队列中未取消的节点转移到同步队列中，以便它们可以依次获取资源继续完成后面的事情，因为逻辑上差不多，这里也不再叙述，有兴趣的同学可以自己看看。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本篇讲述的是ReentrantLock中用到的条件变量Condition，是由AQS的内部类ConditionObject实现的，ConditionObject维护着一个以AQS内部类Node为节点的等待队列，这是一个单链表，等待队列里的都是调用了await方法后等待被唤醒的节点。ConditionObject主要用两个方法，await和signal方法。其中await方法主要是创建一个保存当前线程的Node节点并放在等待队列中，然后将线程持有的资源完全释放然后将线程挂起，直到线程被唤醒或被中断时，会将节点转移同步队列中，以便线程可以在同步队列中有再次获取资源的资格；而signal方法主要是将节点从等待队列转移到同步队列中，以便线程可以在同步队列中有再次获取资源的资格。await和signal需要配合使用，才能维护共享资源的同步。</p><p>源码虽然枯燥无味，但是它包含着精髓，同学们需要细细品味，加油鸭！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码分析之——ReentrantLock</title>
      <link href="/10026/"/>
      <url>/10026/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ReentrantLock是Lock接口的实现类，是一把可以支持重入的锁，静态内部抽象类Sync继承了AQS（AbstractQueuedSynchronizer，不了解AQS的可以看看<a href="https://silentao.com/2019/04/08/10016/">JDK源码分析之——AQS</a>），Sync的子类FairSync、NonfairSync分别实现了公平锁和非公平锁。与synchronized相比，重入锁有着显式的操作过程，开发人员必须手动指定何时加锁，何时释放锁。所以，重入锁对逻辑控制的灵活性要远远好于synchronized。ReentrantLock具有以下特点：</p><ol><li>支持重入性，能够对共享资源重复加锁，即获得锁的线程再次获取锁时不需要被阻塞；</li><li>支持公平锁和非公平锁；</li><li>支持中断响应；</li><li>支持锁申请等待限时；</li><li>支持锁申请快速失败。</li></ol><p>以上特点都会在源码中一一体现，在注释中也做了简单的说明，细心的同学一定会发现哦。</p><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h2><p>ReentrantLock有两个构造方法，无参构造方法默认是创建非公平锁，入参boolean类型的构造方法通过true和false决定创建什么样的锁，其中true创建公平锁，false创建非公平锁。其中公平锁和非公平锁由静态内部类FairSync和NonfairSync实现（具体实现下面会写）,构造方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法默认是创建非公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造方法</span></span><br><span class="line"><span class="comment"> * true创建公平锁，false创建非公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Sync"><a href="#2-Sync" class="headerlink" title="2.Sync"></a>2.Sync</h2><p>静态内部抽象类Sync继承了AQS，并实现了AQS的独占模式，这里只重写了tryRelease方法，tryAcquire方法都是放在子类中去重写的，具体源码解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里定义为抽象方法的lock方法</span></span><br><span class="line"><span class="comment">     * 是为非公平版本提供快速路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在这里实现非公平锁的tryAcquire方法</span></span><br><span class="line"><span class="comment">     * 是因为两种方式的锁对应的tryLock方法都需要调用这个方法</span></span><br><span class="line"><span class="comment">     * 而两种方式的锁真正的tryAcquire方法都将在子类中实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程对象，用于后面比较锁的持有对象是否为当前线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取state值，state在这里表示加锁的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// state为0表示当前锁没有被任何线程持有</span></span><br><span class="line">            <span class="comment">// 通过CAS的方式尝试去修改state的值</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 修改成功表示获得锁</span></span><br><span class="line">                <span class="comment">// 把当前线程对象赋值给exclusiveOwnerThread变量</span></span><br><span class="line">                <span class="comment">// 标记当前持有锁的线程对象</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// 锁被当前线程持有</span></span><br><span class="line">            <span class="comment">// 就在state加上acquires（重入的概念）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 修改state的值</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁，其实就是修改state的值</span></span><br><span class="line"><span class="comment">     * 每释放一次锁state就减1</span></span><br><span class="line"><span class="comment">     * 加了几次锁，就得释放几次锁</span></span><br><span class="line"><span class="comment">     * state == 0时锁才完全释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="comment">// 持有锁的不是当前线程支持抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果state == 0表示锁已经完全释放</span></span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 将持有锁定的标记置为null</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改state的值</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断持有锁的线程是否为当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-NonfairSync"><a href="#3-NonfairSync" class="headerlink" title="3.NonfairSync"></a>3.NonfairSync</h2><p>非公平锁的实现类NonfairSync，重写了lock方法和tryAcquire方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平锁调用加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不判断当前锁是否已经被占有</span></span><br><span class="line">        <span class="comment">// 尝试直接获得锁，有可能抢在等待队列中的线程之前获得锁</span></span><br><span class="line">        <span class="comment">// 体现了非公平锁的概念</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 成功获得锁</span></span><br><span class="line">            <span class="comment">// 把当前线程对象赋值给exclusiveOwnerThread变量</span></span><br><span class="line">            <span class="comment">// 标记当前持有锁的线程对象</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 调用AQS的acquire方法获得锁</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平锁加锁，其实就是修改state的值</span></span><br><span class="line"><span class="comment">     * 每加一次锁state就加1</span></span><br><span class="line"><span class="comment">     * 具体实现在nonfairTryAcquire方法中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-FairSync"><a href="#4-FairSync" class="headerlink" title="4.FairSync"></a>4.FairSync</h2><p>公平锁的实现类FairSync，也重写了lock方法和tryAcquire方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平锁调用加锁</span></span><br><span class="line"><span class="comment">     * 直接调用AQS的acquire方法获得锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平锁加锁</span></span><br><span class="line"><span class="comment">     * 没有其它线程在等待锁，或者当前线程是等待队列的第一个</span></span><br><span class="line"><span class="comment">     * 才有资格尝试去获得锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程对象，用于后面比较锁的持有对象是否为当前线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取state值，state在这里表示加锁的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// state为0表示当前锁没有被任何线程持有</span></span><br><span class="line">            <span class="comment">// 在没有其它线程在等待锁</span></span><br><span class="line">            <span class="comment">// 或者当前线程是等待队列的第一个时</span></span><br><span class="line">            <span class="comment">// 才通过CAS的方式尝试去修改state的值</span></span><br><span class="line">            <span class="comment">// 体现了公平锁的概念</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 修改成功表示获得锁</span></span><br><span class="line">                <span class="comment">// 把当前线程对象赋值给exclusiveOwnerThread变量</span></span><br><span class="line">                <span class="comment">// 标记当前持有锁的线程对象</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// 锁被当前线程持有</span></span><br><span class="line">            <span class="comment">// 就在state加上acquires（重入的概念）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改state的值</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前线程之前是否有线程在等待锁</span></span><br><span class="line"><span class="comment"> * 如果当前线程之前有一个排队的线程返回true</span></span><br><span class="line"><span class="comment"> * 如果当前线程位于队列的开头或队列为空返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-ReentrantLock的常用方法"><a href="#5-ReentrantLock的常用方法" class="headerlink" title="5.ReentrantLock的常用方法"></a>5.ReentrantLock的常用方法</h2><h3 id="5-1-加锁"><a href="#5-1-加锁" class="headerlink" title="5.1 加锁"></a>5.1 加锁</h3><p>加锁方式有好几种，大致可分为直接加锁、支持中断响应的加锁、支持快速失败的加锁、支持超时的加锁，因为具体加锁的实现都已经由AQS和ReentrantLock的内部类Sync、NonfairSync和FairSync实现好饿了，所以ReentrantLock加锁就变得很简单，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持中断响应的加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持快速失败的加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持超时的加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-释放锁"><a href="#5-2-释放锁" class="headerlink" title="5.2 释放锁"></a>5.2 释放锁</h3><p>释放锁的方式就一种，也很简单，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>重入锁使用java.util.concurrent.locks.ReentrantLock类来实现的，它完全可以替代synchronized关键字。与synchronized相比，重入锁有着显式的操作过程，开发人员必须手动指定何时加锁，何时释放锁。所以，重入锁对逻辑控制的灵活性要远远好于synchronized。重入锁对于一个线程是可以反复进入的，也就是说，一个线程可以多次获得同一把锁，只不过需要注意的是，如果同一个线程多次获得锁，那么在释放锁的时候，也必须释放相同的次数。在ReentrantLock的实现中，主要包含三个要素：原子状态，原子状态使用CAS操作来存储当前锁的状态，判断是否已经被别的线程持有；等待队列，所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作；阻塞原语park()和unpark()，用来挂起和恢复线程，没有得到锁的线程将会被挂起。</p><p>Wait a minute，重入锁ReentrantLock是不是还有一个很重要的条件变量Condition类没有讲啊。是的，看了这么多代码和注释，同学们都累了吧，所以Condition类，我们下次再讲吧^_^</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码分析之——FutureTask</title>
      <link href="/10025/"/>
      <url>/10025/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FutureTask是提供了一个可取消的异步计算的过程类，FutureTask实现了Future的基本方法，提供了start和cancel操作，可以查询计算是否已经完成，并且可以获取计算的结果。结果只可以在计算完成之后获取，当计算没有完成的时候get方法会阻塞，一旦计算已经完成，那么计算就不能再次启动或是取消。一个FutureTask可以用来包装一个Callable或是一个Runnable对象。因为FurtureTask实现了Runnable方法，所以一个FutureTask可以提交（submit）给一个Excutor执行（excution）。</p><p>FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。另外，FutureTask还可以确保即使调用了多次run方法，它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。</p><p>在获取任务执行结果时，FutureTask内部维护了一个由WaitNode类实现的简单链表，它保存了所有等待返回数据的线程，并在结果返回之前将这些线程挂起，只有等任务执行完成或者等待超时时才会唤醒这些线程。</p><h2 id="1-状态"><a href="#1-状态" class="headerlink" title="1.状态"></a>1.状态</h2><p>FutureTask内部维护了一个用volatile修饰的int型成员state来表示状态，其中共有7种状态，具体如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="comment">// 新建状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 正在执行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 完成状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 异常状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 取消状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 正在中断状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 中断状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>可能发生的状态转换：</p><ul><li>NEW -&gt; COMPLETING -&gt; NORMAL</li><li>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</li><li>NEW -&gt; CANCELLED</li><li>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</li></ul><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><h3 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h3><p>FutureTask提供了两个构造方法，分别可以包装Callable和Runable的对象，并将状态初始化为NEW。因为Runable没有返回，所以包装Runable时，会将Runable封装在RunnableAdapter类里，RunnableAdapter的call方法返回的就是构造方法传进来的result，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="comment">// 将状态初始化为NEW</span></span><br><span class="line">    <span class="built_in">this</span>.state = NEW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">    <span class="comment">// 将Runable包装为RunnableAdapter类</span></span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="comment">// 将状态初始化为NEW</span></span><br><span class="line">    <span class="built_in">this</span>.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-内部类WaitNode"><a href="#2-2-内部类WaitNode" class="headerlink" title="2.2 内部类WaitNode"></a>2.2 内部类WaitNode</h3><p>FutureTask使用内部类WaitNode构建了一个简单的单链表用来记录等待任务执行结果的线程，并将这个类对象实例放在waiters成员变量上，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待结果的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WaitNode</span> &#123;</span><br><span class="line">    <span class="comment">// 等待的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    <span class="comment">// 构造方法，将当前线程赋值给thread</span></span><br><span class="line">    WaitNode() &#123;</span><br><span class="line">        thread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-run"><a href="#2-3-run" class="headerlink" title="2.3 run"></a>2.3 run</h3><p>run方法是线程执行任务的关键方法，具体任务执行逻辑的调用和返回值的获取及异常捕获都在这个方法进行，具体过程如下：</p><ol><li>如果当前不是新建状态，直接return；</li><li>将当前线程通过CAS赋值给runner成员变量，以便调用cancel方法时可以对线程发起中断，这里保证了任务只会执行一次；</li><li>然后调用callable对象的call方法执行任务，这里会再次校验状态是否为新建状态；</li><li>获取call方法的返回值，并通过set方法赋值到outcome成员变量中，这里会有NEW -&gt; COMPLETING -&gt; NORMAL的状态变化；</li><li>如果call异常，捕获异常后通过setException方法标记异常，这里会有NEW -&gt; COMPLETING -&gt; EXCEPTIONAL的状态变化；</li><li>到这里已经执行完了，最后将runner置为null，如果状态是正在中断或中断状态，调用handlePossibleCancellationInterrupt方法执行线程让步，确保来自cancel（true）的任何中断仅在运行或runAndReset时才传递给任务。</li></ol><p>具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务执行方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断是否为新建状态</span></span><br><span class="line">    <span class="comment">// 2.将当前线程通过CAS赋值给runner成员变量，保证了任务只会执行一次</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="comment">// 不满足则直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前任务对应的callable对象</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// double check state</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 捕获异常</span></span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 标记异常</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">// 将结果赋值到outcome成员变量中</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner必须为非空，直到任务执行完成</span></span><br><span class="line">        <span class="comment">// 以确保任务只执行一次</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 必须在runner为空后重新读取状态，以防止中断被遗漏</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            <span class="comment">// 如果正在中断或中断状态</span></span><br><span class="line">            <span class="comment">// 调用handlePossibleCancellationInterrupt执行线程让步</span></span><br><span class="line">            <span class="comment">// 确保来自cancel（true）的任何中断仅在运行或runAndReset时才传递给任务</span></span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-1-set"><a href="#2-3-1-set" class="headerlink" title="2.3.1 set"></a>2.3.1 set</h4><p>任务执行完成结果赋值及成功状态转换，并唤醒所有正在等待任务结果的线程，这里会有NEW -&gt; COMPLETING -&gt; NORMAL的状态变化，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务执行完成结果赋值及成功状态转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">// 将结果赋值给outcome</span></span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">// 标记为成功状态</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL);</span><br><span class="line">        <span class="comment">// 唤醒并移除所有等待结果的线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒并移除所有等待结果的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 将waiters变量置为null</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 循环遍历单链表</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒等待线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="literal">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="literal">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-setException"><a href="#2-3-2-setException" class="headerlink" title="2.3.2 setException"></a>2.3.2 setException</h4><p>如果call异常，捕获异常后通过setException方法标记异常，这里会有NEW -&gt; COMPLETING -&gt; EXCEPTIONAL的状态变化，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记异常</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">// 将异常信息赋值给outcome</span></span><br><span class="line">        outcome = t;</span><br><span class="line">        <span class="comment">// 标记为异常状态</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL);</span><br><span class="line">        <span class="comment">// 唤醒并移除所有等待结果的线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-handlePossibleCancellationInterrupt"><a href="#2-3-2-handlePossibleCancellationInterrupt" class="headerlink" title="2.3.2 handlePossibleCancellationInterrupt"></a>2.3.2 handlePossibleCancellationInterrupt</h4><p>handlePossibleCancellationInterrupt方法执行线程让步，确保来自cancel（true）的任何中断仅在运行或runAndReset时才传递给任务，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保来自cancel（true）的任何中断仅在运行或runAndReset时才传递给任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePossibleCancellationInterrupt</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">    <span class="comment">// chance to interrupt us.  Let&#x27;s spin-wait patiently.</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            <span class="comment">// 等待待处理的中断</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-get"><a href="#2-4-get" class="headerlink" title="2.4 get"></a>2.4 get</h3><p>get方法是用来获取任务执行的结果，有两个重载的方法，一个带超时时间，一个不带超时时间。两个方法在任务执行完成之前都会将线程挂起，带超时时间的get方法会在超时后抛出TimeoutException，不带超时时间的get方法会一直被挂起，两个方法都会响应中断并抛出InterruptedException，线程被唤醒后会调用report方法获取并返回任务执行结果，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不带超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        <span class="comment">// 任务还未执行完成</span></span><br><span class="line">        <span class="comment">// 挂起当前线程，没有超时时间</span></span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// 获取并返回任务执行结果</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="comment">// 任务还未执行完成并且挂起超时，抛出TimeoutException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">    <span class="comment">// 获取并返回任务执行结果</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-1-awaitDone"><a href="#2-4-1-awaitDone" class="headerlink" title="2.4.1 awaitDone"></a>2.4.1 awaitDone</h4><p>等待任务完成，或者中断任务或等待超时时中止，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待和超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 等待结果节点</span></span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 标记是否已将当前等待节点加入等待链表waiters</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 线程中断则移除当前等待节点</span></span><br><span class="line">            <span class="comment">// 并抛出InterruptedException</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="comment">// 当前状态 &gt; COMPLETING表示任务已经完成或者被取消或者异常或者被中断</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 将等待节点thread置为null</span></span><br><span class="line">                <span class="comment">// 以便等待节点可以被回收</span></span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">            <span class="comment">// 任务正在执行</span></span><br><span class="line">            <span class="comment">// 线程让步以待任务执行完成</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 创建当前的等待节点</span></span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">// 将当前等待节点加入到等待链表waiters头部</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset,</span><br><span class="line">                                                    q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待已经超时，移除节点</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 线程挂起</span></span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 线程挂起</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将超时或者被中断的等待节点移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeWaiter</span><span class="params">(WaitNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="literal">null</span>;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 重新开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">WaitNode</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>, q = waiters, s; q != <span class="literal">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 将thread不为null的节点作为先驱节点</span></span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 先驱节点不为null</span></span><br><span class="line">                    <span class="comment">// 将thread为null的节点移除</span></span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">// 先驱节点的thread为null</span></span><br><span class="line">                        <span class="comment">// 重新遍历</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset,</span><br><span class="line">                                                        q, s))</span><br><span class="line">                    <span class="comment">// 当前节点的thread为null并且pred为null</span></span><br><span class="line">                    <span class="comment">// 就将下一个节点s通过CAS修改waiters的头结点</span></span><br><span class="line">                    <span class="comment">// 然后重新遍历</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-report"><a href="#2-4-2-report" class="headerlink" title="2.4.2 report"></a>2.4.2 report</h4><p>获取并返回任务执行结果，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取并返回任务执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="comment">// 如果状态等于NORMAL表示任务执行完成</span></span><br><span class="line">        <span class="comment">// 返回正常结果</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="comment">// 状态 &gt;= CANCELLED表示任务被取消或者任务被中断</span></span><br><span class="line">        <span class="comment">// 抛出CancellationException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="comment">// 否则任务执行异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-cancel"><a href="#2-5-cancel" class="headerlink" title="2.5 cancel"></a>2.5 cancel</h3><p>取消任务执行，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消任务执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mayInterruptIfRunning true：表示中断任务；false：表示取消任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW,</span><br><span class="line">                mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="comment">// 非新建状态</span></span><br><span class="line">        <span class="comment">// 或者修改状态失败都返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="comment">// 中断任务</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 添加中断标记</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 修改中断状态</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒并移除所有等待结果的线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><ol><li><p>FutureTask是通过LockSupport来阻塞线程、唤醒线程；</p></li><li><p>对于多线程访问成员变量waiters、state，都采用CAS来操作。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾收集器</title>
      <link href="/10023/"/>
      <url>/10023/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。这里讨论的收集器基于JDK 1.7 Update 14之后的 HotSpot 虚拟机，这个虚拟机包含的所有收集器如下图所示：</p><p><img src="/img/backend/10023_01.png" alt="Java垃圾收集器" title="Java垃圾收集器"></p><p>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器，了解它们的部分运作细节。</p><h2 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h2><p>Serial收集器是最基本、发展历史最悠久的收集器，曾经是虚拟机新生代收集的唯一选择。这是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。”Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图示意了Serial&#x2F;Serial Old收集器的运行过程：</p><p><img src="/img/backend/10023_02.png" alt="Serial/Serial Old收集器的运行过程" title="Serial/Serial Old收集器的运行过程"></p><p>实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p><h2 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如下图所示:</p><p><img src="/img/backend/10023_03.png" alt="ParNew收集器的工作过程" title="ParNew收集器的工作过程"></p><p>ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器（并发收集器，后面有介绍）配合工作。</p><p>ParNew收集器在单CPU的环境中不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（如32个)的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p><p>注意，从ParNew收集器开始，后面还会接触到几款并发和并行的收集器。这里有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ol><li><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p></li></ol><h2 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？</p><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。</p><p>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p><p>MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p><p>GCTimeRatio参数的值应当是一个0到100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即 1&#x2F;（1+19）），默认值为99，就是允许最大1%（即 1&#x2F;（1+99））的垃圾收集时间。</p><p>由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。</p><h2 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h2><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure 时使用。这两点都将在后面的内容中详细讲解。Serial Old收集器的工作过程如下图所示：</p><p><img src="/img/backend/10023_04.png" alt="Serial Old收集器的工作过程" title="Serial Old收集器的工作过程"></p><h2 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h2><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。</p><p>原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（Parallel Scavenge收集器无法与CMS收集器配合工作）。</p><p>由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew加CMS的组合“给力”。</p><p>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作过程如下图所示：</p><p><img src="/img/backend/10023_05.png" alt="Parallel Old收集器的工作过程" title="Parallel Old收集器的工作过程"></p><h2 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</p><p>从名字（包含”Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p><ol><li><p>初始标记（CMS initial mark）</p></li><li><p>并发标记（CMS concurrent mark）</p></li><li><p>重新标记（CMS remark）</p></li><li><p>并发清除（CMS concurrent sweep）</p></li></ol><p>其中，初始标记、重新标记这两个步骤仍然需要”Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。CMS收集器的工作过程如下图所示：</p><p><img src="/img/backend/10023_06.png" alt="CMS收集器的工作过程" title="CMS收集器的工作过程"></p><p>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，但是CMS还远达不到完美的程度，它有以下3个明显的缺点：</p><ol><li><p>导致吞吐量降低。CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）&#x2F;4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</p></li><li><p>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现”Concurrent Mode Failure”失败而导致另一次Full GC（新生代和老年代同时回收）的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK 1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK 1.6中，CMS收集器的启动阈值已经提升至92% 。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高很容易导致大量”Concurrent Mode Failure”失败，性能反而降低。</p></li><li><p>产生空间碎片。 CMS是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC 。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC 后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p></li></ol><h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h2><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。</p><h3 id="7-1-G1收集器的特点"><a href="#7-1-G1收集器的特点" class="headerlink" title="7.1 G1收集器的特点"></a>7.1 G1收集器的特点</h3><p>与其他GC收集器相比，G1具备如下特点：</p><ol><li><p>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p></li><li><p>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p></li><li><p>空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC 。</p></li><li><p>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p></li></ol><h3 id="7-2-G1的内存结构"><a href="#7-2-G1的内存结构" class="headerlink" title="7.2 G1的内存结构"></a>7.2 G1的内存结构</h3><p>理解垃圾回收机制，必须先了解G1的内存结构，在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。内存结构如下图：</p><p><img src="/img/backend/10023_07.png" alt="G1的内存结构" title="G1的内存结构"></p><p>这里有三个关于内存的概念：代，区和内存分段。</p><p>G1把堆内存分为年轻代和老年代。年轻代分为Eden和Survivor两个区，老年代分为Old和Humongous两个区。代和区都是逻辑概念。G1把堆内存分为大小相等的内存分段，默认情况下会把内存分为2048个内存分段，可以用-XX:G1HeapRegionSize调整内存分段的个数。比如32G堆内存，2048个内存分段每段的大小为16M。这相当于把内存化整为零。内存分段是物理概念，代表实际的物理内存空间。每个内存分段都可以被标记为Eden区，Survivor区，Old区，或者Humongous区。这样属于不同代，不同区的内存分段就可以不必是连续内存空间了。</p><p>新分配的对象会被分配到Eden区的内存分段上，每一次年轻代的回收过程都会把Eden区存活的对象复制到Survivor区的内存分段上，把Survivor区继续存活的对象年龄加1，如果Survivor区的存活对象年龄达到某个阈值（比如15，可以设置），Survivor区的对象会被复制到Old区。复制过程是把源内存分段中所有存活的对象复制到空的目标内存分段上，复制完成后，源内存分段没有了存活对象，变成了可以使用的空的Eden内存分段了；而目标内存分段的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。Humongous区用于保存大对象，如果一个对象占用的空间超过内存分段的一半（比如上面的8M），则此对象将会被分配在Humongous区。如果对象的大小超过一个甚至几个分段的大小，则对象会分配在物理连续的多个Humongous分段上。Humongous对象因为占用内存较大并且连续会被优先回收。</p><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由），保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><h3 id="7-3-Remembered-Set"><a href="#7-3-Remembered-Set" class="headerlink" title="7.3 Remembered Set"></a>7.3 Remembered Set</h3><p>理解回收过程，需要先了解记忆集合（Remembered Set），以下简称RS。为了在回收单个内存分段的时候不必对整个堆内存的对象进行扫描（单个内存分段中的对象可能被其他内存分段中的对象引用）引入了RS数据结构。RS使得G1可以在年轻代回收的时候不必去扫描老年代的对象，从而提高了性能。每一个内存分段都对应一个RS，RS保存了来自其他分段内的对象对于此分段的引用。对于属于年轻代的内存分段（Eden和Survivor区的内存分段）来说，RS只保存来自老年代的对象的引用。这是因为年轻代回收是针对全部年轻代的对象的，反正所有年轻代内部的对象引用关系都会被扫描，所以RS不需要保存来自年轻代内部的引用。对于属于老年代分段的RS来说，也只会保存来自老年代的引用，这是因为老年代的回收之前会先进行年轻代的回收，年轻代回收后Eden区变空了，G1会在老年代回收过程中扫描Survivor区到老年代的引用。</p><p>RS里的引用信息是怎么样填充和维护的呢？简而言之就是JVM会对应用程序的每一个引用赋值语句object.field&#x3D;object进行记录和处理，把引用关系更新到RS中。但是这个RS的更新并不是实时的。G1维护了一个Dirty Card Queue。对于应用程序的引用赋值语句object.field&#x3D;object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RS，保证RS实时准确的反映引用关系。那为什么不在引用赋值语句处直接更新RS呢？这是为了性能的需要，RS的处理需要线程同步，开销会很大，使用队列性能会好很多。</p><p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><h3 id="7-4-G1收集器的工作过程"><a href="#7-4-G1收集器的工作过程" class="headerlink" title="7.4 G1收集器的工作过程"></a>7.4 G1收集器的工作过程</h3><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p><ol><li><p>初始标记（Initial Marking）</p></li><li><p>并发标记（Concurrent Marking）</p></li><li><p>最终标记（Final Marking）</p></li><li><p>筛选回收（Live Data Counting and Evacuation）</p></li></ol><p>G1 的前几个步骤的运作过程和 CMS 有很多相似之处。</p><p>初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。</p><p>并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</p><p>而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</p><p>最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段：</p><p><img src="/img/backend/10023_08.png" alt="G1收集器的工作过程" title="G1收集器的工作过程"></p><h3 id="7-5-G1年轻代回收过程（Young-GC）"><a href="#7-5-G1年轻代回收过程（Young-GC）" class="headerlink" title="7.5 G1年轻代回收过程（Young GC）"></a>7.5 G1年轻代回收过程（Young GC）</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当所有的Eden区都满了，G1会启动一次年轻代垃圾回收过程。年轻代只会回收Eden区和Survivor区。首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。然后开始如下回收过程：</p><p>第一阶段，扫描根。</p><p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RS记录的外部引用作为扫描存活对象的入口。</p><p>第二阶段，更新RS。</p><p>处理dirty card queue中的card，更新RS。此阶段完成后，RS可以准确的反映老年代对所在的内存分段中对象的引用。</p><p>第三阶段，处理RS。</p><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p><p>第四阶段，复制对象。</p><p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。</p><p>第五阶段，处理引用。</p><p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。</p><h3 id="7-6-G1老年代并发标记过程（Concurrent-Marking）"><a href="#7-6-G1老年代并发标记过程（Concurrent-Marking）" class="headerlink" title="7.6 G1老年代并发标记过程（Concurrent Marking）"></a>7.6 G1老年代并发标记过程（Concurrent Marking）</h3><p>当整个堆内存（包括老年代和新生代）被占满一定大小的时候（默认是45%，可以通过-XX:InitiatingHeapOccupancyPercent进行设置），老年代回收过程会被启动。具体检测堆内存使用情况的时机是年轻代回收之后或者houmongous对象分配之后。老年代回收包含标记老年代内的对象是否存活的过程，标记过程是和应用程序并发运行的（不需要Stop-The-World）。</p><p>应用程序会改变指针的指向，并发执行的标记过程怎么能保证标记过程没有问题呢？并发标记过程有一种情形会对存活的对象标记不到。假设有对象A，B和C，一开始的时候B.c&#x3D;C，A.c&#x3D;null。当A的对象树先被扫描标记，接下来开始扫描B对象树，此时标记线程被应用程序线程抢占后停下来，应用程序把A.c&#x3D;C，B.c&#x3D;null。当标记线程恢复执行的时候C对象已经标记不到了，这时候C对象实际是存活的，这种情形被称作对象丢失。G1解决的方法是在对象引用被设置为空的语句（比如B.c&#x3D;null)时，把原先指向的对象（C对象）保存到一个队列，代表它可能是存活的。然后会有一个重新标记（Remark）过程处理这些对象，重新标记过程是Stop-The-World的，所以可以保证标记的正确性。上述这种标记方法被称为开始时快照技术（SATB，Snapshot At The Begging）。这种方式会造成某些是垃圾的对象也被当做是存活的，所以G1会使得占用的内存被实际需要的内存大。</p><p>具体标记过程如下：</p><ol><li><p>先进行一次年轻代回收过程，这个过程是Stop-The-World的。老年代的回收基于年轻代的回收（比如需要年轻代回收过程对于根对象的收集，初始的存活对象的标记）。</p></li><li><p>恢复应用程序线程的执行。</p></li><li><p>开始老年代对象的标记过程。此过程是与应用程序线程并发执行的。标记过程会记录弱引用情况，还会计算出每个分段的对象存活数据（比如分段内存活对象所占的百分比）。</p></li><li><p>Stop-The-World。</p></li><li><p>重新标记（Remark）。此阶段重新标记前面提到的STAB队列中的对象（例子中的C对象），还会处理弱引用。</p></li><li><p>回收百分之百为垃圾的内存分段。注意：不是百分之百为垃圾的内存分段并不会被处理，这些内存分段中的垃圾是在混合回收过程（Mixed GC）中被回收的。由于Humongous对象会独占整个内存分段，如果Humongous对象变为垃圾，则内存分段百分百为垃圾，所以会在第一时间被回收掉。</p></li><li><p>恢复应用程序线程的执行。</p></li></ol><h3 id="7-7-混合回收过程（Mixed-GC）"><a href="#7-7-混合回收过程（Mixed-GC）" class="headerlink" title="7.7 混合回收过程（Mixed GC）"></a>7.7 混合回收过程（Mixed GC）</h3><p>并发标记过程结束以后，紧跟着就会开始混合回收过程。混合回收的意思是年轻代和老年代会同时被回收。并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，-XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><h3 id="7-8-Full-GC"><a href="#7-8-Full-GC" class="headerlink" title="7.8 Full GC"></a>7.8 Full GC</h3><p>Full GC是指上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。要避免Full GC的发生，一旦发生需要进行调整。什么时候回发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc，这种情况可以通过增大内存解决。</p><h3 id="7-9-其他概念"><a href="#7-9-其他概念" class="headerlink" title="7.9 其他概念"></a>7.9 其他概念</h3><p>1.线程本地分配缓冲区（TLAB: Thread Local Allocation Buffer）</p><p>由于堆内存是应用程序共享的，应用程序的多个线程在分配内存的时候需要加锁以进行同步。为了避免加锁，提高性能每一个应用程序的线程会被分配一个TLAB。TLAB中的内存来自于G1年轻代中的内存分段。当对象不是Humongous对象，TLAB也能装的下的时候，对象会被优先分配于创建此对象的线程的TLAB中。这样分配会很快，因为TLAB隶属于线程，所以不需要加锁。</p><p>2.GC“提升”线程本地分配缓冲区（PLAB: Promotion Thread Local Allocation Buffer）</p><p>前面提到过，G1会在年轻代回收过程中把Eden区中的对象复制（“提升”）到Survivor区中，Survivor区中的对象复制到Old区中。G1的回收过程是多线程执行的，为了避免多个线程往同一个内存分段进行复制，那么复制的过程也需要加锁。为了避免加锁，G1的每个线程都关联了一个PLAB，这样就不需要进行加锁了。</p><p>3.Remembered Set粒度</p><p>其实RS的存储分三种粒度，前面提到的Card是最小的一种粒度。粒度的存在是因为某些内存分段中的对象可能很热门，被来自非常多的区的对象所引用，为了避免保存太多的数据，会以更大的粒度来保存这些引用，比如最大的粒度是用一个bitmap来保存其他内存分段对RS所对应的内存分段的引用。每一个内存分段对应一个bit，如果bit为0表示该bit对应的内存分段中没有引用，为1表示有引用。这种方式会减少RS的数据，但是会增加扫描和标记时的开销，因为需要扫描所有bit为1的内存分段中的对象以确定具体是来自哪个对象的引用。 </p><blockquote><p>本文摘自《深入理解Java虚拟机》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis键的生存时间和过期删除策略</title>
      <link href="/10024/"/>
      <url>/10024/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis中的键是可以设置生存时间的，在经过指定的时间后，Redis服务器会自动删除生存时间为0的键。本文将介绍Redis中键的生存时间是如何保存的，以及过期键是如何删除的。</p><h2 id="1-键的生存时间"><a href="#1-键的生存时间" class="headerlink" title="1.键的生存时间"></a>1.键的生存时间</h2><h3 id="1-1-设置生存时间"><a href="#1-1-设置生存时间" class="headerlink" title="1.1 设置生存时间"></a>1.1 设置生存时间</h3><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p><ol><li><p>EXPIRE &lt;key&gt; &lt;ttl&gt; 命令用于将键key的生存时间设置为ttl秒。</p></li><li><p>PEXPIRE &lt;key&gt; &lt;ttl&gt; 命令用于将键key的生存时间设置为ttl毫秒。</p></li><li><p>EXPIREAT &lt;key&gt; &lt;timestamp&gt; 命令用于将key的过期时间设置为timestamp所指定的秒数时间戳。</p></li><li><p>PEXPIREAT &lt;key&gt; &lt;timestamp&gt; 命令用于将key的过期时间设置为timestamp所指定的毫秒数时间戳。</p></li></ol><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，都将最终转换为PEXPIREAT命令来执行。</p><p>首选，EXPIRE命令可以转换为PEXPIRE命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def EXPIRE(key, ttl_in_sec):</span><br><span class="line">    # 将TTL从秒转换成毫秒</span><br><span class="line">    ttl_in_ms = sec_to_ms(ttl_in_sec)</span><br><span class="line"></span><br><span class="line">    # 再调用PEXPIRE命令</span><br><span class="line">    PEXPIRE(key, ttl_in_ms)</span><br></pre></td></tr></table></figure><p>接着，PEXPIRE命令又可以转换成PEXPIREAT命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def PEXPIRE(key, ttl_in_ms):</span><br><span class="line">    # 获取以毫秒计算的当前UNIX时间戳</span><br><span class="line">    now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line"></span><br><span class="line">    # 当前时间加上TTL，得出毫秒格式的过期时间</span><br><span class="line">    # 再调用PEXPIREAT命令</span><br><span class="line">    PEXPIREAT(key, now_ms + ttl_in_ms)</span><br></pre></td></tr></table></figure><p>并且，EXPIREAT命令也可以转换成PEXPIREAT命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def EXPIREAT(key, expire_time_in_sec):</span><br><span class="line">    # 将过期时间从秒转换成毫秒</span><br><span class="line">    expire_time_in_ms = sec_to_ms(expire_time_in_sec)</span><br><span class="line"></span><br><span class="line">    # 再调用PEXPIREAT命令</span><br><span class="line">    PEXPIREAT(key, expire_time_in_ms)</span><br></pre></td></tr></table></figure><p>最终，EXPIRE、PEXPIRE、EXPIREAT三个命令都会转换成PEXPIREAT命令来执行。</p><h3 id="1-2-保存过期时间"><a href="#1-2-保存过期时间" class="headerlink" title="1.2 保存过期时间"></a>1.2 保存过期时间</h3><p>在redisDb结构的expire字典保存了数据库中所有键的过期时间，我们称这个字典为过期时间字典：</p><ol><li><p>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</p></li><li><p>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</p></li></ol><p>具体结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 过期字典，保存着键的过期时间</span><br><span class="line">    dict *expires;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>当客户端执行PEXPIREAT命令（或者其他三个会转换成PEXPIREAT命令的命令）为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。其中键空间的键和过期字典的键都是指向同一个键对象，所以不会出现任何重复对象，也不会浪费任何空间。</p><p>以下是PEXPIREAT命令的伪代码定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def PEXPIREAT(key, expire_time_in_ms):</span><br><span class="line">    # 如果给定的键不存在于键空间，那么不能设置过期时间</span><br><span class="line">    if key not in redisDb.dict:</span><br><span class="line">        return 0</span><br><span class="line">    </span><br><span class="line">    # 在过期字典中关联键和过期时间</span><br><span class="line">    redisDb.expires[key] = expire_time_in_ms</span><br><span class="line"></span><br><span class="line">    # 过期时间设置成功</span><br><span class="line">    return 1</span><br></pre></td></tr></table></figure><h3 id="1-3-移除过期时间"><a href="#1-3-移除过期时间" class="headerlink" title="1.3 移除过期时间"></a>1.3 移除过期时间</h3><p>PERSIST命令可以移除一个键的过期时间，PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p><p>以下是PERSIST命令的伪代码定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def PERSIST(key):</span><br><span class="line">    # 如果键不存在，或者键没有设置过期时间，那么直接返回</span><br><span class="line">    if key not in redisDb.expires:</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">    # 移除过期字典中给定键的键值对关联</span><br><span class="line">    redisDb.expires.remove(key)</span><br><span class="line"></span><br><span class="line">    # 键的过期时间移除成功</span><br><span class="line">    return 1</span><br></pre></td></tr></table></figure><h3 id="1-4-计算并返回剩余生存时间"><a href="#1-4-计算并返回剩余生存时间" class="headerlink" title="1.4 计算并返回剩余生存时间"></a>1.4 计算并返回剩余生存时间</h3><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。</p><p>以下是TTL和PTTL两个命令的伪代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def PTTL(key):</span><br><span class="line">    # 键不存在于数据库</span><br><span class="line">    if key not in redisDb.dict:</span><br><span class="line">        return -2</span><br><span class="line">    </span><br><span class="line">    # 尝试获得键的过期时间</span><br><span class="line">    # 如果键没有设置过期时间，那么expire_time_in_ms将为None</span><br><span class="line">    expire_time_in_ms = redisDb.expires.get(key)</span><br><span class="line"></span><br><span class="line">    # 键没有设置过期时间</span><br><span class="line">    if expire_time_in_ms is None:</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line">    # 获得当前时间</span><br><span class="line">    now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line"></span><br><span class="line">    # 过期时间减去当前时间，得出的差就是键剩余生存时间</span><br><span class="line">    return (expire_time_in_ms - now_ms)</span><br><span class="line"></span><br><span class="line">def TTL(key):</span><br><span class="line">    ## 获取当前已毫秒为单位的剩余生存时间</span><br><span class="line">    ttl_in_ms = PTTL(key)</span><br><span class="line"></span><br><span class="line">    if ttl_in_ms &lt; 0:</span><br><span class="line">        # 处理返回值为-1和-2的情况</span><br><span class="line">        return ttl_in_ms</span><br><span class="line">    else:</span><br><span class="line">        # 将毫秒转换为秒</span><br><span class="line">        return ms_to_sec(ttl_in_ms)</span><br></pre></td></tr></table></figure><h3 id="1-5-过期键的判定"><a href="#1-5-过期键的判定" class="headerlink" title="1.5 过期键的判定"></a>1.5 过期键的判定</h3><p>通过过期字典，程序可以用以下步骤检查一下给定键是否过期：</p><ol><li><p>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</p></li><li><p>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</p></li></ol><p>可以用一段伪代码来描述这一过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def is_expired(key):</span><br><span class="line">    # 取得键的过期时间</span><br><span class="line">    expire_time_in_ms = redisDb.expires.get(key)</span><br><span class="line"></span><br><span class="line">    # 键没有设置过期时间</span><br><span class="line">    if expire_time_in_ms is None:</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    # 获得当前时间</span><br><span class="line">    now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line"></span><br><span class="line">    # 检查当前时间是否大于键的过期时间</span><br><span class="line">    if now_ms &gt; expire_time_in_ms:</span><br><span class="line">        # 是，键已过期</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        # 否，键未过期</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h2 id="2-过期键删除策略"><a href="#2-过期键删除策略" class="headerlink" title="2.过期键删除策略"></a>2.过期键删除策略</h2><p>如果一个键过期了，这里提供了三种不同的删除策略去删除过期的键：</p><ol><li><p>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键过期的删除操作。</p></li><li><p>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；否则，返回该键。</p></li><li><p>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p></li></ol><h3 id="2-1-定时删除"><a href="#2-1-定时删除" class="headerlink" title="2.1 定时删除"></a>2.1 定时删除</h3><p>定时删除策略是对内存最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</p><p>另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分的CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</p><h3 id="2-2-惰性删除"><a href="#2-2-惰性删除" class="headerlink" title="2.2 惰性删除"></a>2.2 惰性删除</h3><p>惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</p><p>惰性删除策略的缺点是：它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会被释放。</p><h3 id="2-3-定期删除"><a href="#2-3-定期删除" class="headerlink" title="2.3 定期删除"></a>2.3 定期删除</h3><p>从上面来看，定时删除和惰性删除在单一使用时都有明显的缺陷：</p><ol><li><p>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</p></li><li><p>惰性删除浪费太多内存，有内存泄露的危险。</p></li></ol><p>定期删除策略是前两种方式的整合和折中：</p><ol><li><p>定期删除策略每隔一段时间执行一次删除过期键的操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。</p></li><li><p>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</p></li></ol><p>定期删除策略的难点是确定删除操作执行的时长和频率：</p><ol><li><p>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</p></li><li><p>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</p></li></ol><h2 id="3-Redis的过期删除策略"><a href="#3-Redis的过期删除策略" class="headerlink" title="3.Redis的过期删除策略"></a>3.Redis的过期删除策略</h2><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h3 id="3-1-惰性删除策略的实现"><a href="#3-1-惰性删除策略的实现" class="headerlink" title="3.1 惰性删除策略的实现"></a>3.1 惰性删除策略的实现</h3><p>过期键的惰性删除策略由db.c&#x2F;expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p><ol><li><p>如果输入键已经过期，那么expireIfNeeded函数对输入键从数据库中删除。</p></li><li><p>如果输入键未过期，那么expireIfNeeded函数不做动作。</p></li></ol><h3 id="3-2-定期删除策略的实现"><a href="#3-2-定期删除策略的实现" class="headerlink" title="3.2 定期删除策略的实现"></a>3.2 定期删除策略的实现</h3><p>过期键的定期删除策略由redis.c&#x2F;activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c&#x2F;serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定时间内，分多次遍历服务器中的各个数据库，从数据库expires字典中随记检查一部分键的过期时间，并删除其中的过期键。</p><p>activeExpireCycle函数的工作模式可以总结如下：</p><ol><li><p>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</p></li><li><p>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。</p></li><li><p>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</p></li></ol><blockquote><p>本文摘自《Redis的设计与实现》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收机制</title>
      <link href="/10022/"/>
      <url>/10022/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外的人想进去，墙里面的人想出来。</p><p>Java内存运行时区域中的程序计数器、虚拟机栈、本地方法栈随线程而生灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化），因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而Java堆不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</p><p><img src="/img/backend/10022_01.png" alt="JVM运行时数据区域图" title="JVM运行时数据区域图"></p><p>垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身。换言之，垃圾回收只会负责释放那些对象占有的内存。对象是个抽象的词，包括引用和其占据的内存空间。当对象没有任何引用时其占据的内存空间随即被收回备用，此时对象也就被销毁。但不能说是回收对象，可以理解为一种文字游戏。</p><h2 id="1-判断对象是否存活"><a href="#1-判断对象是否存活" class="headerlink" title="1.判断对象是否存活"></a>1.判断对象是否存活</h2><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，需要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即没有任何途径使用的对象）。</p><h3 id="1-1-引用计数器"><a href="#1-1-引用计数器" class="headerlink" title="1.1 引用计数器"></a>1.1 引用计数器</h3><p>给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是不可能再被使用的，简单高效，缺点是无法解决对象之间相互循环引用的问题。</p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p>通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots没有任何引用链相连时，则证明此对象是不可用的。此算法解决了上述循环引用的问题。</p><p><img src="/img/backend/10022_02.png" alt="可达性分析算法判定对象是否可回收" title="可达性分析算法判定对象是否可回收"></p><p>在Java语言中，可作为 GC Roots 的对象包括下面几种：</p><ol><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象。</p></li><li><p>方法区中类静态属性引用的对象。</p></li><li><p>方法区中常量引用的对象。</p></li><li><p>本地方法栈中 JNI（Native方法）引用的对象</p></li></ol><p>作为GC Roots的节点主要在全局性的引用与执行上下文中。要明确的是，tracing gc必须以当前存活的对象集为Roots，因此必须选取确定存活的引用类型对象。GC管理的区域是Java堆，虚拟机栈、方法区和本地方法栈不被GC所管理，因此选用这些区域内引用的对象作为GC Roots，是不会被GC所回收的。</p><p>其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是GC roots的一部分。</p><h3 id="1-3-引用类型"><a href="#1-3-引用类型" class="headerlink" title="1.3 引用类型"></a>1.3 引用类型</h3><p>在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。而JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p><ol><li><p>强引用就是指在程序代码之中普遍存在的，类似”Object obj&#x3D;new Object()”这类的引用，垃圾收集器永远不会回收存活的强引用对象。</p></li><li><p>软引用就是指还有用但并非必需的对象。在系统 将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。</p></li><li><p>弱引用也是用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。</p></li><li><p>虚引用是最弱的一种引用关系。无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></li></ol><p><img src="/img/backend/10022_03.png" alt="引用类型" title="引用类型"></p><h3 id="1-4-可达性分析过程"><a href="#1-4-可达性分析过程" class="headerlink" title="1.4 可达性分析过程"></a>1.4 可达性分析过程</h3><p>不可达的对象将暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ol><li><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。</p></li><li><p>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。</p></li><li><p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。</p></li><li><p>这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，因为如果一个对象在finalize()方法中执行缓慢，将很可能会一直阻塞F-Queue队列，甚至导致整个内存回收系统崩溃。</p></li></ol><p>使用finalize()方法来“拯救”对象的方法是不值得提倡的，它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()能做的工作，使用try-finally或者其它方法都更适合、及时，所以可以尽量忘记这个方法的存在。</p><h3 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a>1.5 回收方法区</h3><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><ol><li><p>回收废弃常量与回收Java堆中的对象非常类似，假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”abc”的，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个”abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p></li><li><p>要判断一个类是否是“无用的类”的条件则相对苛刻许多，类需要满足以下3个条件才能算“无用的类”：</p></li></ol><ul><li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</p></li><li><p>加载该类的ClassLoader已经被回收。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。</p><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h2><p>垃圾回收算法是垃圾回收的理论基础，这里介绍四种垃圾回收算法：标记-清除算法、复制算法、标记-整理算法及分代收集算法。</p><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h3><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>它的主要不足有两个：</p><ol><li><p>效率问题，标记和清除两个过程的效率都不高；</p></li><li><p>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p></li></ol><p>标记—清除算法的执行过程如下图：</p><p><img src="/img/backend/10022_04.png" alt="标记—清除算法的执行过程" title="标记—清除算法的执行过程"></p><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h3><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。复制算法的执行过程如下图：</p><p><img src="/img/backend/10022_05.png" alt="复制算法的执行过程" title="复制算法的执行过程"></p><p>现在的商业虚拟机都采用这种算法来回收新生代，IBM研究指出新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden:Survivor &#x3D; 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（其中一块Survivor不可用），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p><p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块 Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p><h3 id="2-3-标记整理算法"><a href="#2-3-标记整理算法" class="headerlink" title="2.3 标记整理算法"></a>2.3 标记整理算法</h3><p>复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如下：</p><p><img src="/img/backend/10022_06.png" alt="标记整理算法的执行过程" title="标记整理算法的执行过程"></p><h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象存活周期的不同将内存划分为几块并采用不用的垃圾收集算法。</p><p>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><h2 id="3-HotSpot的算法实现"><a href="#3-HotSpot的算法实现" class="headerlink" title="3.HotSpot的算法实现"></a>3.HotSpot的算法实现</h2><h3 id="3-1-枚举根节点"><a href="#3-1-枚举根节点" class="headerlink" title="3.1 枚举根节点"></a>3.1 枚举根节点</h3><p>以可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p><p>另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须不可以出现分析过程中对象引用关系还在不断变化的情况，否则分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为”Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><p>因此，目前的主流Java虚拟机使用的都是准确式GC（即虚拟机可以知道内存中某个位置的数据具体是什么类型。），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。</p><p>在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p><h3 id="3-2-安全点（Safepoint）"><a href="#3-2-安全点（Safepoint）" class="headerlink" title="3.2 安全点（Safepoint）"></a>3.2 安全点（Safepoint）</h3><p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</p><p>实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始GC ，只有在到达安全点时才能暂停。</p><p>Safepoint的选定既不能太少以致于GC过少，也不能过于频繁以致于过分增大运行时的负荷。对于Safepoint，另一个需要考虑的问题是如何在GC 发生时让所有线程都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。</p><ol><li><p>其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p></li><li><p>而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p></li></ol><h3 id="3-3-安全区域（Safe-Region）"><a href="#3-3-安全区域（Safe-Region）" class="headerlink" title="3.3 安全区域（Safe Region）"></a>3.3 安全区域（Safe Region）</h3><p>使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><blockquote><p>本文摘自《深入理解Java虚拟机》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令总结</title>
      <link href="/10021/"/>
      <url>/10021/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init 初始化git</span><br><span class="line">git remote add origin &lt;git地址&gt; 连接远程仓库</span><br><span class="line">git <span class="built_in">clone</span> &lt;git地址&gt; 克隆远程仓库到本地</span><br></pre></td></tr></table></figure><h2 id="2-提交和推送"><a href="#2-提交和推送" class="headerlink" title="2.提交和推送"></a>2.提交和推送</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git status 可以看到项目中有哪些文件发生了变化</span><br><span class="line">git add . 把发生了变化的文件添加进来</span><br><span class="line">git commit -am <span class="string">&#x27;&#x27;</span> 提交文件到本地仓库</span><br><span class="line">git pull 把远程分支上的文件拉取过来</span><br><span class="line">git push </span><br><span class="line">git push -u origin master 把本地仓库文件推送到远程仓库中</span><br><span class="line">git push -u -f origin master 把本地仓库文件强制推送到远程仓库中</span><br><span class="line">git push origin HEAD -u 把新创建的分支推送到远程仓库</span><br><span class="line">git cherry-pick (commit <span class="built_in">id</span>) 合并某次commit到当前分支</span><br><span class="line">git checkout .清空工作区，只能清空全部已修改的问题件</span><br><span class="line">git clean -d 清空所有新建的文件和文件夹</span><br><span class="line">git reset .清空暂存区</span><br></pre></td></tr></table></figure><h2 id="3-分支管理"><a href="#3-分支管理" class="headerlink" title="3.分支管理"></a>3.分支管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git branch 查看本地分支</span><br><span class="line">git branch -r 查看远程分支</span><br><span class="line">git checkout &lt;name&gt; 切换分支</span><br><span class="line">git branch &lt;name&gt; 创建分支</span><br><span class="line">git checkout -b &lt;本地分支名&gt; origin/&lt;远程分支名&gt; 在&lt;远程分支名&gt;的基础上创建&lt;本地分支名&gt;</span><br><span class="line">git fetch origin &lt;远程分支名&gt;:&lt;本地分支名&gt; 在&lt;远程分支名&gt;的基础上创建&lt;本地分支名&gt;</span><br><span class="line">git checkout -b &lt;name&gt; 创建+切换分支</span><br><span class="line">git merge &lt;name&gt; 合并某分支到当前分支</span><br><span class="line">git branch -d &lt;name&gt; 删除分支</span><br><span class="line">git branch -r -d origin/&lt;name&gt; 删除远程分支</span><br><span class="line">git branch | [grep <span class="string">&quot;&lt;关键字&gt;&quot;</span>] | xargs git branch -D 批量删除[有&lt;关键字&gt;的]本地分支</span><br></pre></td></tr></table></figure><h2 id="4-git配置"><a href="#4-git配置" class="headerlink" title="4.git配置"></a>4.git配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;你的git的注册邮箱&quot;</span> 设置邮箱</span><br><span class="line">git config --global user.user <span class="string">&quot;你的git用户名&quot;</span> 设置用户名</span><br><span class="line">git config --global credential.helper cache 设置记住密码（默认15分钟）</span><br><span class="line">git config credential.helper <span class="string">&#x27;cache --timeout=3600&#x27;</span> 设置保存一个小时时间</span><br><span class="line">git config --global credential.helper store 长期保存本地配置</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引优化总结</title>
      <link href="/10020/"/>
      <url>/10020/</url>
      
        <content type="html"><![CDATA[<ol><li>如果MySQL估计使用索引比全表扫描还慢，则不会使用索引；</li><li>前导模糊查询不能命中索引,在做模糊查询时,不要把通配符放在最前面,否则不会命中索引；</li><li>数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来；</li><li>复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引；</li><li>union、in、or都能够命中索引，建议使用in:or&gt;in&gt;union；</li><li>用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到;</li><li>负向条件查询不能使用索引，可以优化为in查询,负向条件有：!&#x3D;、&lt;&gt;、not in、not exists、not like等；</li><li>数据库执行计算不会命中索引,不要查询条件中使用表达式；</li><li>利用覆盖索引进行查询，避免回表；</li><li>建立索引的列，不允许为null；</li><li>更新十分频繁的字段上不宜建立索引：因为更新操作会变更B+树，重建索引。这个过程是十分消耗数据库性能的；</li><li>区分度不大的字段上不宜建立索引：类似于性别这种区分度不大的字段，建立索引的意义不大。因为不能有效过滤数据，性能和全表扫描相当。另外返回数据的比例在30%以外的情况下，优化器不会选择使用索引；</li><li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。虽然唯一索引会影响insert速度，但是对于查询的速度提升是非常明显的。另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，在并发的情况下，依然有脏数据产生；</li><li>多表关联时，要保证关联字段上一定有索引；</li><li>创建索引时避免以下错误观念：索引越多越好，认为一个查询就需要建一个索引；宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度；抵制唯一索引，认为业务的唯一性一律需要在应用层通过“先查后插”方式解决；过早优化，在不了解系统的情况下就开始优化；</li><li>没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题；</li><li>当只要一行数据时使用LIMIT 1。</li></ol><blockquote><p>后续总结再补充</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码分析之——ThreadLocal</title>
      <link href="/10019/"/>
      <url>/10019/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。  </p><p>ThreadLocal的存储结构如下：</p><p><img src="/img/backend/10019/10019_1.png" alt="ThreadLocal的存储结构如下"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap类是ThreadLocal的静态内部类。每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。这样的设计主要有以下几点优势：</p><ol><li><p>这样设计之后每个ThreadLocalMap的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量，能提高性能；</p></li><li><p>当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</p></li></ol><p>ThreadLocalMap就是以ThreadLocal对象为key的简易版的HashMap，通过静态内部类Entry来存储key和value，使用线性探测的方式来解决哈希冲突的问题，并且提供了基本的元素增删改查和扩容的方法。这里要讲的是ThreadLocalMap的静态内部类Entry，Entry继承了WeakReference并使用ThreadLocal的弱引用作为key，先来看一下Entry的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弱引用的对象在jvm下一次进行gc的时候就会被回收，对象内存空间就会被释放，于是就会产生这样一个问题：</p><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果外部没有ThreadLocal对象的强引用，只是作为局部变量来使用的话，那么在下一次gc时ThreadLocal对象就会被回收，ThreadLocalMap中对应的Entry就会出现key为null的情况，这些key对应的value也将无法再访问，但是value却有一个来自当前线程的强引用，因此只有等这个线程销毁时，value才能真正的被回收。但是当我们在使用线程池的情况时，核心线程是一直在运行的，线程对象不会被回收，于是就可能出现内存泄漏的问题。</p><p>对象之间的引用结构图如下：</p><p><img src="/img/backend/10019/10019_2.png" alt="对象之间的引用结构图如下"></p><p>ThreadLocalMap使用了线性探测来处理哈希冲突的问题，并在这个过程中将那些key为null的Entry和对应的value清理掉了，具体实现在expungeStaleEntry方法中，可以看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将key为空的Entry和对应的value置为null</span></span><br><span class="line">    <span class="comment">// 以便gc时把对应的对象回收掉</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 同时map的数量减1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性探测只到为null</span></span><br><span class="line">    <span class="comment">// 期间会清理key为null的Entry</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">            i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将key为空的Entry和对应的value置为null</span></span><br><span class="line">            <span class="comment">// 以便gc时把对应的对象回收掉</span></span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调整Entry的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expungeStaleEntry方法执行完后，key为null的Entry到value对象就不会存在强引用了，在gc时Entry和value对象就会被回收，自然就不存在内存泄漏的问题。查看expungeStaleEntry方法的调用位置可以知道，在ThreadLocalMap的getEntry、set和remove方法中，都会调用expungeStaleEntry方法。当我不需要获取value也不需要set value时，还是可能会出现内存泄漏问题，这是可能就需要手动的调用ThreadLocal的remove方法来防止内存泄漏。</p><p>其实，最好的方式就是将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，可以防止内存泄露。</p><h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a>initialValue</h3><p>initialValue()方法是protected类型的，很显然是建议在子类重载该函数的，所以通常该方法都会以匿名内部类的形式被重载，以指定初始值。当调用get()方法的时候，若是与当前线程关联的ThreadLocal值已经被设置过，则不会调用initialValue()方法；否则，会调用initialValue()方法来进行初始值的设置。通常initialValue()方法每个线程只会调用一次，除非调用了remove()方法之后又调用get()方法，此时，与当前线程关联的ThreadLocal值处于没有设置过的状态（其状态体现在源码中，就是线程的ThreadLocalMap对象是否为null），initialValue()方法仍会被调用。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>获取与当前线程关联的ThreadLocal值，废话不多说，直接看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 根据当前线程对象，获取线程对于的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;<span class="comment">// map不为空</span></span><br><span class="line">        <span class="comment">// 以当前ThreadLocal对象的引用获取map中对于的value</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="comment">// value不为空直接返回</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 对象线程的ThreadLocal对象进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取当前线程的ThreadLocalMap对象</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ThreadLocal初始化方法</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 通过调用子类重载的initialValue获取ThreadLocal关联的对象</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 以当前TheadLocal对象为key，将value set到map中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// map为空，则创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 给当前线程对象创建ThreadLocalMap对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal的实现离不开ThreadLocalMap类，get其实就是去当前线程的ThreadLocalMap里获取以ThreadLocal对象为key对应Entry的值，大致过程如下：</p><ol><li>对应的值已经存在就直接返回；</li><li>否则调用initialValue方法获取初始值；</li><li>如果ThreadLocalMap不为空就将初始值以ThreadLocal为key存入ThreadLocalMap对象中；</li><li>否则就创建当前对象的ThreadLocalMap对象并存入初始值；</li><li>最后返回初始值。</li></ol><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>设置与当前线程关联的ThreadLocal值，依然不多废话，直接看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 先获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 以当前TheadLocal对象为key，将value set到map中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// map为空，则创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>将与当前线程关联的ThreadLocal值删除，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 调用ThreadLocalMap的remove方法删除与当前线程关联的ThreadLocal对象</span></span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>①ThreadLocal并不解决线程间共享数据的问题；<br>②ThreadLocal通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题；<br>③每个线程持有一个Map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题；<br>④ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理机制</title>
      <link href="/10018/"/>
      <url>/10018/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>程序运行时，发生的不被期望的事件，它阻止了程序按照程序员的预期正常执行，这就是异常。而异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。<br>Java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw 语句手动抛出的，只要在Java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。</p><h2 id="1-Java异常类结构图"><a href="#1-Java异常类结构图" class="headerlink" title="1.Java异常类结构图"></a>1.Java异常类结构图</h2><p>Throwable类是Java异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。我们可以自定义异常，JDK中内建了一些常用的异常类，如下图所示：<br><img src="/img/backend/throwable.jpg"></p><h2 id="2-Java异常分类"><a href="#2-Java异常分类" class="headerlink" title="2.Java异常分类"></a>2.Java异常分类</h2><p>2.1根据继承关系可分为错误（Error）和异常（Exception），它们都继承自Throwable。其中RuntimeException又继承自Exception，而Error和RuntimeException及其子类称为未检查异常（Unchecked exception），它们的区别是：<br>①错误（Error）：Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。如：java.lang.StackOverFlowError和Java.lang.OutOfMemoryError。对于这类错误，Java编译器不去检查他们，即为未检查异常（Unchecked exception），且这类错误一旦发生将会导致应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止；</p><p>②异常（Exception）：Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。其中RuntimeException和其子类为运行时异常（Runtime Exception），即未检查异常（Unchecked exception）；而Exception的其它子类为非运行异常，即受检查异常（Checked Exception）。具体区别可见下文分解。</p><p>2.2根据Javac对异常的处理要求，将异常类分为未检查异常（Unchecked exception），其它异常成为受检查异常（Checked Exception），它们的区别是：<br>①非检查异常（unckecked exception）：Error和RuntimeException以及它们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等；</p><p>②检查异常（checked exception）：除了Error和RuntimeException以及它们的子类以外的异常，javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException, IOException,ClassNotFoundException等。</p><h2 id="3-throw和throws"><a href="#3-throw和throws" class="headerlink" title="3.throw和throws"></a>3.throw和throws</h2><p>①throw是用来抛出任意异常的，你可以抛出任意Throwable，包括自定义的异常类对象；</p><p>②throws总是出现在一个函数头中，用来标明该成员方法可能抛出的各种异常。如果方法抛出了异常，那么调用这个方法的时候就需要处理这个异常。</p><h2 id="4-try-catch-finally-return"><a href="#4-try-catch-finally-return" class="headerlink" title="4.try-catch-finally-return"></a>4.try-catch-finally-return</h2><p>①不管是否有异常产生，finally块中代码都会执行；</p><p>②当try和catch中有return语句时，finally块仍然会执行；</p><p>③finally是在return后面的表达式运算后执行的，所以函数返回值是在finally执行前确定的。无论finally中的代码怎么样，返回的值都不会改变，仍然是之前return语句中保存的值；</p><p>④finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码分析之——CountDownLatch与CyclicBarrier</title>
      <link href="/10015/"/>
      <url>/10015/</url>
      
        <content type="html"><![CDATA[<p>CountDownLatch与CyclicBarrier都是我们在并发编程中常用的工具，它们提供了一种控制并发流程的手段，今天我们通过源码分析来看看它的真面目。</p><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1.CountDownLatch"></a>1.CountDownLatch</h2><p>CountDownLatch中count down是倒数的意思，latch则是门闩的含义，它通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>CountDownLatch在内部自定义了AQS框架（对AQS不熟悉可以先看一下Java并发之AQS详解），内部类Sync继承了AbstractQueuedSynchronizer并重写了共享模式下的tryAcquireShared-tryReleaseShared方法。AbstractQueuedSynchronizer中维护了一个volatile类型的整数state，volatile可以保证多线程环境下该变量的修改对每个线程都可见，并且由于该属性为整型，因而对该变量的修改也是原子的。CountDownLatch正是通过这个state来标识需要倒数的次数，当创建一个CountDownLatch对象时，所传入的整数n就会赋值给state属性，当countDown()方法调用时，该线程就会尝试对state减一，而调用await()方法时，当前线程就会判断state属性是否为0，如果为0，则继续往下执行，如果不为0，则使当前线程进入等待状态，直到某个线程将state属性置为0，其就会唤醒在await()方法中等待的线程。</p><h3 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2 源码分析"></a>1.2 源码分析</h3><h4 id="1-2-1-构造方法"><a href="#1-2-1-构造方法" class="headerlink" title="1.2.1 构造方法"></a>1.2.1 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-Sync类"><a href="#1-2-2-Sync类" class="headerlink" title="1.2.2 Sync类"></a>1.2.2 Sync类</h4><p>Sync类继承了AbstractQueuedSynchronizer，并重写了共享模式下的tryAcquireShared-tryReleaseShared方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line"> </span><br><span class="line">    Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();<span class="comment">// 获取当前state属性的值</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">// 如果state为0，则说明当前计数器已经计数完成，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;<span class="comment">// 设置成功后返回当前是否为最后一个设置state的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①tryAcquireShared方法：AQS的acquireSharedInterruptibly方法会调用tryAcquireShared方法，tryAcquireShared判断当前state是否为0，如果为0则返回1，对于AQS来说就是获取到了资源，主线程可以继续执行，而这里可以表示其它线程都执行完毕了，主线程可以继续执行；不为0说明还有线程没有执行完，主线程需要继续等待；</p><p>②tryReleaseShared方法：AQS的releaseShared方法会调用tryReleaseShared方法，tryReleaseShared会获取当前的state值，并减1，表示当前线程执行完毕。这里使用了CAS的方式修改state的值，保证了线程安全，如果当前线程是最后一个修改state的线程，那么主线程就可以被唤醒，继续执行。</p><h4 id="1-2-3-countDown"><a href="#1-2-3-countDown" class="headerlink" title="1.2.3 countDown()"></a>1.2.3 countDown()</h4><p>调用此方法的线程会尝试对AQS的state减一，表示当前线程完成了自己的事情。需要注意的是，此方法并没有规定一个线程只能调用一次，当同一个线程调用多次countDown()方法时，每次都会使计数器减一，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里是直接调用AQS的releaseShared方法，目的是在AQS里释放一个资源，其实这里就是将state减一，AQS的releaseShared方法会回调Sync类的tryReleaseShared方法，执行state减一操作，如果当前线程是最后一个操作state的线程，那么就会唤醒等待的主线程，releaseShared方法源码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">//唤醒在等待的主线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-await"><a href="#1-2-4-await" class="headerlink" title="1.2.4 await()"></a>1.2.4 await()</h4><p>调用此方法的主线程会进入同步队列，在其它线程未完成即state还不为0的时候，主线程会被挂起，直到其它线程执行完成后才会被唤醒，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接调用AQS的acquireSharedInterruptibly方法，这是一个会响应中断的方法，如果线程被中断了，就会抛出InterruptedException。AQS的acquireSharedInterruptibly方法会回调Sync类的tryAcquireShared判断state是否为0，不为0则进入同步队列，并被挂起。acquireSharedInterruptibly方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await(long timeout, TimeUnit unit)方法是await()方法的重载方法，会返回一个boolean值，功能和await基本相似。只不过主线程调用这个方法时，会挂起timeout时间，如果这段时间内其它线程完成了任务，返回true，如果超过了timeout还没有完成，则返回false，至于后续如何操作，取决于主线程。</p><h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><p>CountDownLatch实质上就是一个AQS计数器，通过AQS来实现线程的等待与唤醒。</p><h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2.CyclicBarrier"></a>2.CyclicBarrier</h2><p>CyclicBarrier是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点。与CountDownLatch不同的是该barrier在释放等待线程后可以重用，所以称它为循环（Cyclic）的屏障（Barrier）。</p><p>CyclicBarrier支持一个可选的Runnable命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用。</p><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>当前线程等待直到所有线程都调用了该屏障的await()方法，如果当前线程不是将到达的最后一个线程，将会被阻塞。解除阻塞的情况有以下几种：</p><p>①最后一个线程调用await()；<br>②当前线程被中断；<br>③其他正在该CyclicBarrier上等待的线程被中断；<br>④其他正在该CyclicBarrier上等待的线程超时；<br>⑤其他某个线程调用该CyclicBarrier的reset()方法。</p><p>如果当前线程在进入此方法时已经设置了该线程的中断状态或者在等待时被中断，将抛出InterruptedException，并且清除当前线程的已中断状态。</p><p>如果在线程处于等待状态时barrier被reset()或者在调用await()时 barrier 被损坏，将抛出 BrokenBarrierException 异常。</p><p>如果任何线程在等待时被中断，则其他所有等待线程都将抛出 BrokenBarrierException 异常，并将 barrier 置于损坏状态。如果当前线程是最后一个将要到达的线程，并且构造方法中提供了一个非空的屏障操作（barrierAction），那么在允许其他线程继续运行之前，当前线程将运行该操作。如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，并将 barrier 置于损坏状态。</p><p>对于失败的同步尝试，CyclicBarrier 使用了一种要么全部要么全不 (all-or-none) 的破坏模式：如果因为中断、失败或者超时等原因，导致线程过早地离开了屏障点，那么在该屏障点等待的其他所有线程也将通过BrokenBarrierException（如果它们几乎同时被中断，则用 InterruptedException）以反常的方式离开。</p><h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><h4 id="2-2-1-类成员分析"><a href="#2-2-1-类成员分析" class="headerlink" title="2.2.1 类成员分析"></a>2.2.1 类成员分析</h4><p>直接看源码，分析在注释中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内联类，表示当前屏障所属的代，可用于实现重置功能</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">    <span class="comment">//当前的屏障是否破坏</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//重入锁，靠这个锁来保证线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">//需要拦截的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"><span class="comment">//当所有线程到达屏障时，需要执行的屏障操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">//当前的所属的代（Generation），每当屏障失效或者开闸之后都会自动替换掉，从而实现重置的功能</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"><span class="comment">//还需要阻塞的线程数（即parties-当前阻塞的线程数），当新建generation或generation被破坏时，count会被重置。因为对Count的操作都是在获取锁之后，所以不需要其他同步措施。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-构造方法"><a href="#2-2-2-构造方法" class="headerlink" title="2.2.2 构造方法"></a>2.2.2 构造方法</h4><p>有两个构造方法，一个带barrierAction操作，一个不带，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parties表示屏障拦截的线程数量，当屏障撤销时，先执行barrierAction，然后在释放所有线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-await"><a href="#2-2-3-await" class="headerlink" title="2.2.3 await"></a>2.2.3 await</h4><p>await也有两种方式，一种带超时时间，一种不带超时时间，这个方法没有实际的实现，正真的实现在dowait()方法上，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">           BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="literal">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-dowait"><a href="#2-2-4-dowait" class="headerlink" title="2.2.4 dowait"></a>2.2.4 dowait</h4><p>这个方式CyclicBarrier的正真实现，具体实现过程见源码的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获得锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//取得当前屏障所属的代</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//判断当前屏障是否被破坏</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">             </span><br><span class="line">        <span class="comment">//如果当前线程被中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//被中断先对当前屏障进行破坏处理</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="comment">//再抛出中断异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取省下还没有被拦截的线程数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 如果没被拦截的线程数量为0，表示当前线程是最后一个到达屏障的线程</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取并在当前线程执行后续操作</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 标记执行成功</span></span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//重置CyclicBarrier</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction) <span class="comment">// 如果barrierCommand没有执行成功</span></span><br><span class="line">                    breakBarrier();<span class="comment">// 对当前屏障进行破坏处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 如果当前线程不是最后一个到达屏障</span></span><br><span class="line">        <span class="comment">// 则进行自旋直到被唤醒，破坏，中断，或者超时</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed) <span class="comment">// 非超时阻塞</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) <span class="comment">// 超时阻塞</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;<span class="comment">// 阻塞时被中断</span></span><br><span class="line">                <span class="comment">//先判断当前屏障是否被重置并且没有被破坏</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 破坏处理</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// 并抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这种捕获了InterruptException之后调用Thread.currentThread().interrupt()</span></span><br><span class="line">                    <span class="comment">// 是一种通用的方式。其实就是为了保存中断状态</span></span><br><span class="line">                    <span class="comment">// 从而让其他更高层次的代码注意到这个中断。</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果当前屏障被破坏，当前线程抛BrokenBarrierException</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果已经换代，表示当前屏障所有的线程都已经到达屏障</span></span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 超时，进行屏障破坏处理，并抛TimeoutException</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 破坏处理方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将破坏表示置为true</span></span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 重置count</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有被阻塞的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 屏障重置方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 唤醒所有被阻塞的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 重置count</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 创建一个新的代</span></span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-reset"><a href="#2-2-5-reset" class="headerlink" title="2.2.5 reset"></a>2.2.5 reset</h4><p>重置屏障，先进行屏障破坏处理，再设置下一代generation，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-CountDowLatch和CyclicBarrier比较"><a href="#3-CountDowLatch和CyclicBarrier比较" class="headerlink" title="3.CountDowLatch和CyclicBarrier比较"></a>3.CountDowLatch和CyclicBarrier比较</h2><p>①CountDownLatch:一个线程(或者多个)等待另外N个线程完成某个事情之后才能执行；CyclicBarrier:N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待；<br>②CountDownLatch:一次性的；CyclicBarrier:可以重复使用；<br>③CountDownLatch基于AQS；CyclicBarrier基于重入锁和Condition；<br>④本质上都是依赖于volatile和CAS实现的。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码分析之——AQS</title>
      <link href="/10016/"/>
      <url>/10016/</url>
      
        <content type="html"><![CDATA[<p>在Java高并发编程中，我们经常会用到ReentrantLock、CountDownLatch、Semaphore等同步类，它们的功能可能不尽相同，但是它们都有一个共同点，就是实现依赖了AQS（AbstractQueuedSynchronizer）。这是一个抽象的队列同步器，它定义了一套多线程访问共享资源的同步器框架。今天我们通过源码分析来看看它的真面目。</p><h2 id="1-框架"><a href="#1-框架" class="headerlink" title="1.框架"></a>1.框架</h2><p><img src="/img/backend/CLH_Queue.png"></p><p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。state的访问方式有三种:<br>①getState()</p><p>②setState()</p><p>③compareAndSetState()</p><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：<br>①isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它；</p><p>②tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false；</p><p>③tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false；</p><p>④tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源；</p><p>⑤tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state&#x3D;0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="2-源码分析：独占模式"><a href="#2-源码分析：独占模式" class="headerlink" title="2.源码分析：独占模式"></a>2.源码分析：独占模式</h2><p>本节依照acquire-release、acquireShared-releaseShared的次序来讲解AQS的源码。</p><h3 id="2-1-acquire-int"><a href="#2-1-acquire-int" class="headerlink" title="2.1 acquire(int)"></a>2.1 acquire(int)</h3><p>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法流程如下：<br>①tryAcquire()尝试直接去获取资源，如果成功则直接返回；</p><p>②addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</p><p>③acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false；</p><p>④如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</p><h4 id="2-1-1-tryAcquire-int"><a href="#2-1-1-tryAcquire-int" class="headerlink" title="2.1.1 tryAcquire(int)"></a>2.1.1 tryAcquire(int)</h4><p>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get&#x2F;set&#x2F;CAS）至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了。当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p><p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p><h4 id="2-1-2-addWaiter-Node"><a href="#2-1-2-addWaiter-Node" class="headerlink" title="2.1.2 addWaiter(Node)"></a>2.1.2 addWaiter(Node)</h4><p>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">//尝试快速的方式将新节点放入队尾</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当队列为空则通过此方法入队</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node结点是对每一个访问同步代码的线程的封装，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE。<br>①CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化；</p><p>②SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行；</p><p>③CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁；</p><p>④PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</p><p>⑤0状态：值为0，代表初始化状态。</p><p>AQS在判断状态时，通过用waitStatus&gt;0表示取消状态，而waitStatus&lt;0表示有效状态。</p><h5 id="2-1-2-1-enq-Node"><a href="#2-1-2-1-enq-Node" class="headerlink" title="2.1.2.1 enq(Node)"></a>2.1.2.1 enq(Node)</h5><p>此方法用于当同步队列为空时，创建头结点，并将node加入队尾。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//CAS&quot;自旋&quot;，直到成功加入队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//将node节点放入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-acquireQueued-Node-int"><a href="#2-1-3-acquireQueued-Node-int" class="headerlink" title="2.1.3 acquireQueued(Node, int)"></a>2.1.3 acquireQueued(Node, int)</h4><p>通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。接下来应该进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//标记是否获取资源失败</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源</span></span><br><span class="line">            <span class="comment">//可能是老大释放完资源唤醒自己的，当然也可能被interrupt了</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为暂时无法获取到资源，所以先进入waiting状态，直到有资源释放时被unpark()唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-3-1-shouldParkAfterFailedAcquire-Node-Node"><a href="#2-1-3-1-shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="2.1.3.1 shouldParkAfterFailedAcquire(Node, Node)"></a>2.1.3.1 shouldParkAfterFailedAcquire(Node, Node)</h5><p>此方法主要用于检查状态，看看自己是否真的可以进入waiting状态。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//拿到前驱节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果已经设置为了SIGNAL，那就可以直接进入waiting状态了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边</span></span><br><span class="line">        <span class="comment">//注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被GC回收</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-3-2-parkAndCheckInterrupt"><a href="#2-1-3-2-parkAndCheckInterrupt" class="headerlink" title="2.1.3.2 parkAndCheckInterrupt()"></a>2.1.3.2 parkAndCheckInterrupt()</h5><p>此方法就是让线程真正进入等待状态，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用park()使线程进入waiting状态</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//如果被唤醒，查看自己是不是被中断的，注意：此方法会清楚中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 </p><h5 id="2-1-3-3小结"><a href="#2-1-3-3小结" class="headerlink" title="2.1.3.3小结"></a>2.1.3.3小结</h5><p>看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：<br>①结点进入队尾后，检查状态，找到安全休息点；</p><p>②调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</p><p>③被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</p><h4 id="2-1-4小结"><a href="#2-1-4小结" class="headerlink" title="2.1.4小结"></a>2.1.4小结</h4><p>acquireQueued()分析完之后，我们接下来再回到acquire()，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来总结下它的流程吧：</p><p>①调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</p><p>②没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</p><p>③acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</p><p>④如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</p><p>流程图：<br><img src="/img/backend/AQS_process.png"></p><p>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</p><h3 id="2-2-release-int"><a href="#2-2-release-int" class="headerlink" title="2.2 release(int)"></a>2.2 release(int)</h3><p>此方法是独占模式下线程释放共享资源的顶层入口，它会释放指定量的资源，如果彻底释放了（即state&#x3D;0），它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了，所以自定义同步器在设计tryRelease()的时候要明确这一点。</p><h4 id="2-2-1-tryRelease-int"><a href="#2-2-1-tryRelease-int" class="headerlink" title="2.2.1 tryRelease(int)"></a>2.2.1 tryRelease(int)</h4><p>此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-&#x3D;arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state&#x3D;0)，要返回true，否则返回false。</p><h4 id="2-2-2-unparkSuccessor-Node"><a href="#2-2-2-unparkSuccessor-Node" class="headerlink" title="2.2.2 unparkSuccessor(Node)"></a>2.2.2 unparkSuccessor(Node)</h4><p>此方法用于唤醒等待队列中下一个线程。下面是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//node一般为当前线程所在的结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">//如果这个节点不存在，或已经取消等待</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//从队列尾部开始遍历，获取从头部开始算第一个可用的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg))的判断（即使p!&#x3D;head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p&#x3D;&#x3D;head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了，就可以执行线程的自己的任务了。</p><h4 id="2-2-3小结"><a href="#2-2-3小结" class="headerlink" title="2.2.3小结"></a>2.2.3小结</h4><p>release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state&#x3D;0）,它会唤醒等待队列里的其他线程来获取资源。</p><h2 id="3-源码分析：共享模式"><a href="#3-源码分析：共享模式" class="headerlink" title="3.源码分析：共享模式"></a>3.源码分析：共享模式</h2><h3 id="3-1-acquireShared-int"><a href="#3-1-acquireShared-int" class="headerlink" title="3.1 acquireShared(int)"></a>3.1 acquireShared(int)</h3><p>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：<br>①tryAcquireShared()尝试获取资源，成功则直接返回；</p><p>②失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</p><h4 id="3-1-1-doAcquireShared-int"><a href="#3-1-1-doAcquireShared-int" class="headerlink" title="3.1.1 doAcquireShared(int)"></a>3.1.1 doAcquireShared(int)</h4><p>此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//现将当前线程加入队列尾部</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">//是否成功标志</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//等待过程中是否被中断过的标志</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//前驱</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//尝试获取资源</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">//如果等待过程中被打断过，此时将中断补上</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和acquireQueued()很相似，在流程上并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样。</p><p>跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p><h5 id="3-1-1-1-setHeadAndPropagate-Node-int"><a href="#3-1-1-1-setHeadAndPropagate-Node-int" class="headerlink" title="3.1.1.1 setHeadAndPropagate(Node, int)"></a>3.1.1.1 setHeadAndPropagate(Node, int)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">//head指向自己</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式。</p><h4 id="3-1-2小结"><a href="#3-1-2小结" class="headerlink" title="3.1.2小结"></a>3.1.2小结</h4><p>至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：<br>①tryAcquireShared()尝试获取资源，成功则直接返回；</p><p>②失败则通过doAcquireShared()进入等待队列park()，直到被unpark()&#x2F;interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的，其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。</p><h3 id="3-2-releaseShared"><a href="#3-2-releaseShared" class="headerlink" title="3.2 releaseShared()"></a>3.2 releaseShared()</h3><p>上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">//唤醒后继结点</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state&#x3D;0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state&#x3D;0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p><h4 id="3-2-1-doReleaseShared"><a href="#3-2-1-doReleaseShared" class="headerlink" title="3.2.1 doReleaseShared()"></a>3.2.1 doReleaseShared()</h4><p>此方法主要用于唤醒后继。下面是它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//head未发生改变</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3小结"><a href="#3-3小结" class="headerlink" title="3.3小结"></a>3.3小结</h3><p>本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireShared()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()&#x2F;acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireShared()差不多，这里就不再详解了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发中遇到的锁</title>
      <link href="/10014/"/>
      <url>/10014/</url>
      
        <content type="html"><![CDATA[<p>在Java高并发编程中，会遇到各种锁，这里简单介绍一下各种锁的分类。涉及到了以下内容：</p><p>①公平锁&#x2F;非公平锁</p><p>②可重入锁</p><p>③独享锁&#x2F;共享锁</p><p>④互斥锁&#x2F;读写锁</p><p>⑤乐观锁&#x2F;悲观锁</p><p>⑥分段锁</p><p>⑦偏向锁&#x2F;轻量级锁&#x2F;重量级锁</p><p>⑧自旋锁</p><p>上面是很多锁的名称，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><h2 id="1-公平锁-x2F-非公平锁"><a href="#1-公平锁-x2F-非公平锁" class="headerlink" title="1.公平锁&#x2F;非公平锁"></a>1.公平锁&#x2F;非公平锁</h2><p>①公平锁是指多个线程按照申请锁的顺序来获取锁；</p><p>②非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象；</p><p>③对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大；</p><p>④对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS(AbstractQueuedSynchronizer)的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2.可重入锁"></a>2.可重入锁</h2><p>①可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁；</p><p>②对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。；</p><p>③对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p><h2 id="3-独享锁-x2F-共享锁"><a href="#3-独享锁-x2F-共享锁" class="headerlink" title="3.独享锁&#x2F;共享锁"></a>3.独享锁&#x2F;共享锁</h2><p>①独享锁是指该锁一次只能被一个线程所持有；</p><p>②共享锁是指该锁可被多个线程所持有；</p><p>③对于Java ReentrantLock而言，其是独享锁；</p><p>④但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁；</p><p>⑤读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的；</p><p>⑥独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享；</p><p>⑦对于Synchronized而言，当然是独享锁。</p><h2 id="4-互斥锁-x2F-读写锁"><a href="#4-互斥锁-x2F-读写锁" class="headerlink" title="4.互斥锁&#x2F;读写锁"></a>4.互斥锁&#x2F;读写锁</h2><p>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。</p><p>①互斥锁在Java中的具体实现就是ReentrantLock；</p><p>②读写锁在Java中的具体实现就是ReadWriteLock。</p><h2 id="5-乐观锁-x2F-悲观锁"><a href="#5-乐观锁-x2F-悲观锁" class="headerlink" title="5.乐观锁&#x2F;悲观锁"></a>5.乐观锁&#x2F;悲观锁</h2><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p><p>①悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题；</p><p>②乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重试的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的；</p><p>③从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升；</p><p>④悲观锁在Java中的使用，就是利用各种锁；</p><p>⑤乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p><h2 id="6-分段锁"><a href="#6-分段锁" class="headerlink" title="6.分段锁"></a>6.分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h2 id="7-偏向锁-x2F-轻量级锁-x2F-重量级锁"><a href="#7-偏向锁-x2F-轻量级锁-x2F-重量级锁" class="headerlink" title="7.偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>7.偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h2><p>这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p><p>①偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价；</p><p>②轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能；</p><p>③重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h2 id="8-自旋锁"><a href="#8-自旋锁" class="headerlink" title="8.自旋锁"></a>8.自旋锁</h2><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM运行时数据区域</title>
      <link href="/10017/"/>
      <url>/10017/</url>
      
        <content type="html"><![CDATA[<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域依赖用户线程的启动和结束而建立和销毁。<br><img src="/img/backend/jvm.jpg"></p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一个需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的Native方法，这个计数器则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h2 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2.Java虚拟机栈"></a>2.Java虚拟机栈</h2><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。而常说的JVM栈内存就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不属于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其它与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：①如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；②如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，机会抛出OutOfMemoryError异常。</p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。与虚拟机栈一致，本地方法栈区域也会抛出StackOverFlowError和OutOfMemoryError异常。</p><h2 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4.Java堆"></a>4.Java堆</h2><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。即，所有的对象实例以及数组都要在堆上分配。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作为“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再做细致一点儿的有Eden空间、From Survivor空间、To Survivor空间等。从内容分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。</p><p>Java堆中可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。既可以实现成固定大小，也可以是可扩展的。如果在堆中没有内存完成实例分配，并且也无法再扩展（通过-Xmx和-Xms来控制），将会抛出OutOfMemoryError异常。</p><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后得代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为“永久代”，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以向管理Java堆一样管理这部分内存，能够省下专门为方法区编写内存管理代码的工作。</p><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java对一样不需要连续的内存和可以选择固定大小或者可扩展（通过-XX来控制）外，还可以选择不实现垃圾收集。这块区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h2 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6.运行时常量池"></a>6.运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）时方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于Class文件常量池的另外一个重要的特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中。当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h2 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7.直接内存"></a>7.直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于多线程的锁优化</title>
      <link href="/10013/"/>
      <url>/10013/</url>
      
        <content type="html"><![CDATA[<h2 id="1-如何提供锁的性能"><a href="#1-如何提供锁的性能" class="headerlink" title="1.如何提供锁的性能"></a>1.如何提供锁的性能</h2><p>1.1减小锁持有时间：对于使用锁进行并发控制的应用程序而言，在锁竞争的过程中，单个线程的持有时间与系统性能有着直接的关系。减少锁的持有时间有助于降低锁冲突的可能性，进而提高系统的并发能力。</p><p>1.2减小锁粒度：所谓减少锁粒度，就是指缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力。</p><p>1.3读写分离锁来替代独占锁：在读多写少的场合，使用读写锁可以有效提升系统的并发能力。</p><p>1.4锁分离：如果将读写锁的思想做进一步的延伸，就是锁分离。读写锁根据读写操作功能上的不同，进行了有效地分离。依据应用程序的功能特点，使用类似的分离思想，也可以对独占锁进行分离。</p><p>1.5锁粗化：虚拟机在遇到一连串地对同一锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁的粗化。性能优化就是根据运行时的真是情况对各个资源点进行权衡折中的过程。锁粗化的思想和减少锁持有时间是相反的，但在不同的场合，它们的效果并不相同。</p><h2 id="2-Java虚拟机对锁的优化"><a href="#2-Java虚拟机对锁的优化" class="headerlink" title="2.Java虚拟机对锁的优化"></a>2.Java虚拟机对锁的优化</h2><p>2.1锁偏向：如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。</p><p>2.2轻量级锁：轻量级锁的操作也很轻便，它只是简单地将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。</p><p>2.3自旋锁：由于当前线程暂时无法获得锁，但是什么时候能获得锁又是个未知数，所以虚拟机此时会让当前线程做几个空循环（这是自旋的含义），在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能获得锁，才会真是地将线程在操作系统层面挂起。</p><p>2.4锁消除：Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。锁消除涉及的一项技术为逃逸分析，所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。</p><h2 id="3-比较交换（CAS）"><a href="#3-比较交换（CAS）" class="headerlink" title="3.比较交换（CAS）"></a>3.比较交换（CAS）</h2><p>CAS（Compare and swap）算法的过程是这样的：它包含三个参数CAS(V,E,N)。V表示要更新的变量当前在内存中的值，E表示预期值，N表示新值。当且仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池浅析</title>
      <link href="/10012/"/>
      <url>/10012/</url>
      
        <content type="html"><![CDATA[<p>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用，于是我们可以把创建的线程放入一个池子里管理起来，即线程池。在线程池中，总有那么几个活跃线程。当需要使用线程时，可以从池子中随便拿一个空闲线程，当完成工作时，并不急着关闭线程，而是将这个线程退回到池子，方便他人使用。</p><h2 id="1-JDK对线程池的支持"><a href="#1-JDK对线程池的支持" class="headerlink" title="1.JDK对线程池的支持"></a>1.JDK对线程池的支持</h2><p>1.1为了能够更好地控制多线程，JDK提供了一套Executor框架，帮助开发人员有效地进行线程控制，其本质就是一个线程池。<br><img src="/img/backend/thread_pool.png"></p><p>其中ThreadPoolExecutor表示一个线程池，Executor提供了各种类型的线程池，主要有以下工厂方法：</p><p>①newFixedThreadPool()方法，该方法返回一个固定线程池数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂时存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务；</p><p>②newSingleThreadExecutor()方法：该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务；</p><p>③newCachedThreadPool()方法：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若没有可复用的线程，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用；</p><p>④newSingleThreadScheduledExecutor()方法：该方法返回一个ScheduledExecutorService对象，线程池的大小为1。ScheduleExecutorService接口在ExecutorService接口之上扩展了在给定时间执行某个任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务；</p><p>⑤newScheduledThreadPool()方法：该方法也返回一个ScheduleExecutorService对象，但该线程池可以指定线程数量。</p><p>1.2计划任务：ScheduleExecutorService可以根据时间需要对线程进行调度，主要有以下方法：</p><p>①schedule()方法：schedule()方法会在给定时间，对任务进行一次调度；</p><p>②scheduleAtFixedRate()方法：scheduleAtFixedRate()方法任务调度频率是一定的，它是以上一个任务开始执行时间为起点，之后的period时间，调度下一次任务。也就是说，任务开始于给定的初始延时，后续的任务按照给定的周期进行：后续第一个任务将会在initialDelay+period时执行，后续第二个任务将在initialDelay+2 * period时进行，以此类推。周期如果太短，那么任务就会在上一个任务结束后，立即被调用；</p><p>③scheduleWithFixedDelay()方法：scheduleWithFixedDelay()方法则是在上一个任务结束后，再经过delay时间进行任务调度。也就是说，任务开始于初始延时时间，后续任务将会按照给定的延时进行，即上一个任务的结束时间到下一个的开始时间的时间差。</p><p>另外一个值得注意的问题是，调度程序实际上并不保证任务会无限期的持续调用。如果任务本身抛出了异常，那么后续的所有执行都会被中断。如果任务遇到异常，那么后续的所有子任务都会停止调度，因此，必须保证异常被及时处理，为周期性任务的稳定调度提供条件。</p><h2 id="2-线程池ThreadPoolExecutor构造方法参数介绍"><a href="#2-线程池ThreadPoolExecutor构造方法参数介绍" class="headerlink" title="2.线程池ThreadPoolExecutor构造方法参数介绍"></a>2.线程池ThreadPoolExecutor构造方法参数介绍</h2><p>①corePoolSize：指定了线程池中的线程数量；</p><p>②maximumPoolSize：指定了线程池中的最大线程数量；</p><p>③keepAliveTime：当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间。即，超过corePoolSize的空闲线程，在多长时间内，会被销毁；</p><p>④unit：keepAliveTime的单位；</p><p>⑤workQueue：任务队列，被提交但尚未被执行的任务；</p><p>⑥threadFactory：线程工厂，用于创建线程，一般用默认的即可；</p><p>⑦handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。</p><p>参数workQueue指被提交但未执行的任务队列，它是一个BlockingQueue接口的对象，用于存放Runable对象。根据队列功能分类，在ThreadPoolExecutor的构造方法中可使用以下几种BlockingQueue：</p><p>①直接提交队列（SynchronousQueue）：该功能由SynchronousQueue对象提供，SynchronousQueue是一个特殊的BlockingQueue。SynchronousQueue没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如果使用SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程，则尝试创建新的进程，如果线程数量已达到最大值，则执行拒绝策略。因此，使用SynchronousQueue队列，通常要设置很大的maximumPoolSize值，否则很容易执行拒绝策略；</p><p>②有界任务队列（ArrayBlockingQueue）：有界任务队列可以由ArrayBlockingQueue实现，ArrayBlockingQueue的构造方法必须带一个容量参数，表示该队列的最大容量。当使用有界任务队列时，若有新的任务需要执行，如果线程池的实际线程数小于corePoolSize，则会优先创建新的线程，若大于corePoolSize，则会将新的任务加入等待队列，若等待队列已满，无法加入，则在总线程数不大于maximumPoolSize的前提下，创建新的线程执行任务。若大于maximumPoolSize，则执行拒绝策略。可见有界队列仅当在任务队里装满时，才可能将线程数提升到corePoolSize以上，换言之，除非系统非常繁忙，否则确保核心线程数维持在corePoolSize；</p><p>③无界任务队列（LinkedBlockingQueue）：无界任务队列可以通过LinkedBlockingQueue类实现，与有界队列相比，除非系统资源耗尽，否则无界队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数量小于corePoolSize时，线程池会生成新的线程执行任务，但当系统的任务达到corePoolSize，就不会继续增加。若后续仍有新的任务加入，而又没有空闲的线程资源，则任务直接进入任务队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存；</p><p>④优先任务队列（PriorityBlockingQueue）：优先任务队列是带有执行优先级的队列，它通过PriorityBlockingQueue实现，可以控制任务的执行先后顺序，它是一个特殊的无界队列。无论是有界队列ArrayBlockingQueue，还是未指定大小的无界队列LinkedBlockingQueue都是按照先进先出算法处理任务的。而PriorityBlockingQueue则可以根据任务自身的优先级顺序先后执行，在确保系统性能的同时，也能有很好的质量保证（总是确保高优先级的任务先执行）。</p><h2 id="3-拒绝策略"><a href="#3-拒绝策略" class="headerlink" title="3.拒绝策略"></a>3.拒绝策略</h2><p>①AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；</p><p>②CallerRunsPolicy策略：只要线程池为关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，认为提交线程的性能极有可能会急剧下降；</p><p>③DiscardOledestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务；</p><p>④DiscardPolicy策略：该策略默默地丢弃无法处理的任务，不予任何处理。</p><h2 id="4-优化线程池数量"><a href="#4-优化线程池数量" class="headerlink" title="4.优化线程池数量"></a>4.优化线程池数量</h2><p>Ncpu &#x3D; CPU的数量</p><p>Ucpu &#x3D; 目标CPU的使用率，0  &lt;&#x3D; Ucpu &lt;&#x3D; 1</p><p>W&#x2F;C &#x3D; 等待时间与计算时间的比率</p><p>最优的线程池大小等于：</p><p>Nthreads &#x3D; Ncpu * Ucpu * (1 + W&#x2F;C)</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK并发包</title>
      <link href="/10011/"/>
      <url>/10011/</url>
      
        <content type="html"><![CDATA[<h2 id="1-同步控制"><a href="#1-同步控制" class="headerlink" title="1.同步控制"></a>1.同步控制</h2><h3 id="1-1重入锁"><a href="#1-1重入锁" class="headerlink" title="1.1重入锁"></a>1.1重入锁</h3><p>重入锁使用java.util.concurrent.locks.ReentrantLock类来实现的，它完全可以替代synchronized关键字。与synchronized相比，重入锁有着显式的操作过程，开发人员必须手动指定何时加锁，何时释放锁。所以，重入锁对逻辑控制的灵活性要远远好于synchronized。重入锁对于一个线程是可以反复进入的，也就是说，一个线程可以多次获得同一把锁，只不过需要注意的是，如果同一个线程多次获得锁，那么在释放锁的时候，也必须释放相同的次数。</p><p>重入锁的功能：</p><p>①中断响应</p><p>在等待重入锁的过程中，程序可以根据需要取消对锁的请求。过程就是，如果一个线程正在等待锁，那么它依然可以收到一个通知，被告知无须再等待，可以停止工作了。这种情况对死锁是有一定帮助的。</p><p>在对锁的请求时，使用lockInterruptibly()方法，这是一个可以对锁中断进行响应的锁申请动作，即在等待锁的过程中，可以调用interrupt()方法，线程就会响应并中断对锁的等待。</p><p>②锁申请等待限时</p><p>通过调用tryLock()方法设置线程申请锁的等待时间，即限时等待，过了这个等待时间，让线程自动放弃，这也是一种避免死锁的方式。</p><p>tryLock()方法接收两个参数，一个表示等待时长，另外一个表示计时单位。当然，tryLock()方法也可以不接收参数直接运行。这种情况下，当前线程会尝试获得锁，如果锁并未被其它线程占用，则申请锁会成功，并立即返回true；如果锁被其它线程占用，则当前线程不会进行等待，而是立即返回false。这种模式下也不会一起线程等待，因此也不会产生死锁。</p><p>③公平锁</p><p>在大多数情况下，锁的申请是非公平的。也就是说，系统只是会从这个锁的等待队列中随机挑选一个，因此不能保证其公平性。而公平锁，则不是这样，它会按照时间的先后顺序，保证先到者先得，后到者后得。公平锁的一大特点是：它不会产生饥饿现象。</p><p>可以在创建重入锁，new ReentrantLock(true)的时候，在构造方法中传入一个true，来标识这个重入锁是公平的。要实现公平锁必然要求系统维护一个有序队列，因此公平锁的实现成本比较高，性能也相对非常低下。故在默认情况下，锁是非公平的。</p><p>ReentrantLock几个重要的方法：</p><p>①lock()：获得锁，如果锁已经被占用，则等待；</p><p>②lockInterruptibly()：获得锁，但优先响应中断；</p><p>③tryLock()：尝试获得锁，如果成功，返回true，失败返回false。该方法不等待，立即返回；</p><p>④tryLock(long time, TimeUnit unit)：在给定时间内尝试获得锁；</p><p>⑤unlock()：释放锁。</p><p>在重入锁的实现中，主要包含三个要素：</p><p>①是原子状态。原子状态使用CAS操作来存储当前锁的状态，判断是否已经被别的线程持有；</p><p>②是等待队列。所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作；</p><p>③是阻塞原语park()和unpark()，用来挂起和恢复线程，没有得到锁的线程将会被挂起。</p><h3 id="1-2Condition条件"><a href="#1-2Condition条件" class="headerlink" title="1.2Condition条件"></a>1.2Condition条件</h3><p>Condition对象的作用其实和wait()和notify()方法的作用是大致相同的，只不过wait()和notify()是配合synchronized关键字使用的，而Condition是配合重入锁使用的。通过ReentrantLock接口的Condition newCondition()方法可以生成一个与当前重入锁绑定的Condition实例。利用Condition对象，我们就可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知，继续执行。</p><p>Condition方法简介：</p><p>①await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()或者signalAll()方式时，线程就会重新获得锁并继续执行。或者当前线程被中断时，也能跳出来等待；</p><p>②awaitUninterruptibly()方法与await()方法基本相同，但是它并不会在等待过程中响应中断；</p><p>③signal()方法用于唤醒一个在等待中的线程，相对的signalAll()方法会唤醒所有在等待中的线程。</p><p>和Object.wait()和Object.notify()方法一样，当线程使用Condition.await()时，要求线程持有相关的重入锁，在Condition.await()调用后，这个线程会释放这把锁。同理，在调用Condition.signal()方法时，也要求线程先获得相关的锁。</p><h3 id="1-3信号量（Semaphore）"><a href="#1-3信号量（Semaphore）" class="headerlink" title="1.3信号量（Semaphore）"></a>1.3信号量（Semaphore）</h3><p>信号量是为多线程协作提供了更为强大的控制方法。广义上说，信号量是对锁的扩展。无论是内部锁synchronized还是重入锁ReentrantLock，一次都只允许一个线程访问同一个资源，而信号量却可以指定多个线程，同时访问某一个资源。</p><p>在构造信号量对象时，必须要指定信号量的准入数，即同时能申请多少个许可。当每个线程每次只申请一个许可时，这就相当于指定了同时有多少个线程可以访问某一个资源。Semaphore的构造方法还有一个参数，可以指定当前信号量是否是公平的。</p><p>Semaphore方法简介：</p><p>①acquire()方法尝试获得一个准入的许可，若无法获得，则线程会等待，直到有线程释放一个许可或者当前线程被中断；</p><p>②acquireUninterruptibly()方法和acquire()方法类似，但不响应中断；</p><p>③tryAcquire()方法尝试获得一个许可，如果成功返回true，失败则返回false，它不会进行等待，立即返回；</p><p>④tryAcquire(long timeout, TimeUnit unit)方法尝试获得一个许可，如果成功返回true，失败则等待timeout时长，直到获得许可返回true，或者超时返回false；</p><p>⑤release()用于在线程访问资源结束后，释放一个许可，以使其他等待许可的线程可以进行资源访问。</p><h3 id="1-4ReadWriteLock读写锁"><a href="#1-4ReadWriteLock读写锁" class="headerlink" title="1.4ReadWriteLock读写锁"></a>1.4ReadWriteLock读写锁</h3><p>ReadWriteLock是JDK5提供的读写分离锁，读写分离锁可以有效地帮助减少锁竞争，以提升系统性能。读写锁允许多个线程同时读，但是写写操作和读写操作间依然是需要相互等待和持有锁的。读写锁的约束情况如下表所示：</p><table><thead><tr><th></th><th>读</th><th>写</th></tr></thead><tbody><tr><td>读</td><td>非阻塞</td><td>阻塞</td></tr><tr><td>写</td><td>阻塞</td><td>阻塞</td></tr></tbody></table><p>①读-读不互斥：读读之间不阻塞；</p><p>②读-写互斥：读阻塞写，写也会阻塞读；</p><p>③写-写互斥：写写阻塞。</p><h3 id="1-5倒计时器：CountDownLatch"><a href="#1-5倒计时器：CountDownLatch" class="headerlink" title="1.5倒计时器：CountDownLatch"></a>1.5倒计时器：CountDownLatch</h3><p>CountDownLatch通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p><h3 id="1-6循环栅栏：CyclicBarrier"><a href="#1-6循环栅栏：CyclicBarrier" class="headerlink" title="1.6循环栅栏：CyclicBarrier"></a>1.6循环栅栏：CyclicBarrier</h3><p>CyclicBarrier可以理解为循环栅栏，它比CountDownLatch略微强大一些，CyclicBarrier可以接收一个参数作为barrierAction，所谓barrierAction就是当计数器一次计数完成后，系统会执行的动作。</p><p>CyclicBarrier.await()方法可能会抛出两个异常，一个是InterruptedException，也就是在等待过程中，线程被中断，应该说这是一个非常通用的异常。大部分迫使线程等待的方法都可能抛出这个异常，使得线程在等待时依然可以响应外部紧急事件。另外一个异常则是CyclicBarrier特有的BrokenBarrierException。一旦遇上这个异常，则表示当前的CyclicBarrier已经被破坏了，可能系统已经没有办法等待所有线程到齐了。</p><h3 id="1-7线程阻塞工具类：LockSupport"><a href="#1-7线程阻塞工具类：LockSupport" class="headerlink" title="1.7线程阻塞工具类：LockSupport"></a>1.7线程阻塞工具类：LockSupport</h3><p>LockSupport是一个非常方便实用的线程阻塞工具，它可以在线程内任意位置让线程阻塞。和Thread.suspend()相比，它弥补了由于resume()在前发生，导致线程无法继续执行的情况。</p><p>LockSupport类使用类似信号量的机制，它为每一个线程准备了一个许可，如果许可可用，那么park()方法会立即返回，并且消费这个许可（也就是把许可变为不可用），如果许可不可用，就会阻塞。而unpark()则使得一个许可变为可用（但是和信号量不同的是，许可不能累加，你不可能拥有超过一个许可，它永远只有一个）。所以即使unpark()操作发生在park()之前，它也可以使下一次的park()操作立即返回。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程基础</title>
      <link href="/10010/"/>
      <url>/10010/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1.基本特性"></a>1.基本特性</h2><h3 id="1-1特性"><a href="#1-1特性" class="headerlink" title="1.1特性"></a>1.1特性</h3><p>①原子性：原子性是指一个操作是不可中断的；</p><p>②可见性：可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改；</p><p>③有序性：即程序执行的顺序按照代码的先后顺序执行。</p><h3 id="1-2指令重排"><a href="#1-2指令重排" class="headerlink" title="1.2指令重排"></a>1.2指令重排</h3><p>在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列，一般而言，这个指令序列是会输出确定的结果，以确保每一次的执行都有确定的结果。但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化，在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序，在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。</p><p>指令重排是有原则的，并非所有的指令都可以随便改变执行的顺序，以下是基本原则：</p><p>①程序顺序原则：一个线程内保证语义的串行性；</p><p>②volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性；</p><p>③锁规则：解锁（unlock）必然发生在加锁（lock）前；</p><p>④传递性：A先于B，B先于C，那么A必然先于C；</p><p>⑤线程的start()方法先于它的每一个动作；</p><p>⑥线程的所有操作先于线程的终结（Thread.join()）；</p><p>⑦线程的中断（interrupt()）先于被中断线程的代码；</p><p>⑧对象的构造函数执行、结束先于finalize()方法。</p><h2 id="2-线程基础"><a href="#2-线程基础" class="headerlink" title="2.线程基础"></a>2.线程基础</h2><h3 id="2-1线程与进程"><a href="#2-1线程与进程" class="headerlink" title="2.1线程与进程"></a>2.1线程与进程</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程是线程的容器。线程就是轻量级进程，是程序执行的最小单位。使用多线程而不使用多进程进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。</p><h3 id="2-2线程的状态"><a href="#2-2线程的状态" class="headerlink" title="2.2线程的状态"></a>2.2线程的状态</h3><p><img src="/img/backend/thread_status.jpg"></p><p>NEW状态表示刚刚创建的线程，这种线程还没有开始执行。等到线程的start()方法调用时，才表示线程开始执行。当线程执行时，处于RUNNABLE状态，表示线程所需的一切资源都已经准备就绪。如果线程在执行过程中遇到了synchronize同步块，就会进入BLOCKED阻塞状态，这时线程会暂停执行，直到获得了请求的锁。WAITING和TIMED_WAITING都表示等待状态，它们的区别是WAITING会进入一个无时间限制的等待，TIEMD_WAITING会进入一个有时限的等待。当线程执行完毕后，则进入TERMINATED状态，表示结束。</p><p>需要注意的是：从NEW状态出发后，线程不能再回到NEW状态，同理，处于TERMINATED的线程也不能再回到RUNNABLE状态。</p><h2 id="3-线程的基本操作"><a href="#3-线程的基本操作" class="headerlink" title="3.线程的基本操作"></a>3.线程的基本操作</h2><h3 id="3-1新建线程"><a href="#3-1新建线程" class="headerlink" title="3.1新建线程"></a>3.1新建线程</h3><p>Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。Java可以用三种方式来创建线程，如下所示：</p><p>①继承Thread类创建线程；</p><p>②实现Runnable接口创建线程；</p><p>③使用Callable和Future创建线程。</p><p>当创建了一个Thread对象之后，可以调用start()方法，接着start()方法就会新建一个线程并让这个线程执行run()方法。需要注意的是：不要用run()开启新线程，它只会在当前线程中，串行run()方法中的代码。</p><h3 id="3-2终止线程"><a href="#3-2终止线程" class="headerlink" title="3.2终止线程"></a>3.2终止线程</h3><p>如果需要终止线程，可以调用stop()方法，但这是一个已经被JDK废弃的方法。为什么这个方法被废弃呢，Thread.stop()方法在结束线程时，会直接终止线程，并且会立即释放这个线程所持有的锁。而这些锁恰恰是用来维持对象一致性的。如果此时，写程序写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，由于锁已被释放，另外一个等待该锁的读线程就顺理成章的读到了这个不一致的对象。所以，这是一个不推荐使用并且已被废弃的方法。</p><h3 id="3-3线程中断"><a href="#3-3线程中断" class="headerlink" title="3.3线程中断"></a>3.3线程中断</h3><p>线程中断并不会使线程立即退出，而是给线程发送一个通知，告诉目标线程有别的线程希望它退出，至于目标线程接到通知后如何处理，则完全由目标线程自行决定。</p><p>Thread.sleep()方法会让当前线程休眠若干时间，它会抛出一个InterruptedException中断异常。InterruptedException不是运行时异常，也就是说程序必须捕获并且处理它，当线程在sleep()休眠时，如果被中断，这个异常就会产生。需要注意的是：Thread.sleep()方法由于中断而抛出异常，此时，它会清除中断标记，如果不加处理，那么在下一次循环开始时，就无法捕获这个中断，故在异常处理中，需再次设置中断标记位。</p><h3 id="3-4等待（wait）和通知"><a href="#3-4等待（wait）和通知" class="headerlink" title="3.4等待（wait）和通知"></a>3.4等待（wait）和通知</h3><p>当在一个对象实例上调用object.wait()方法后，当前线程就会在这个对象上等待，停止继续执行，状态转为等待状态，并进入对象实例的等待队列。在等待队列中，可能会有多个线程，因为系统运行多个线程同时等待某一个对象。</p><p>只有当object.notify()被调用时，它就会从这个等待队列中，随机选择一个线程，将其唤醒（这里唤醒指的是从等待状态变为就绪状态，而不是马上继续执行，要等CPU分配了执行的时间片该线程才能够继续执行）。除了notify()方法外，Object对象还有一个类似的方法notifyAll()方法，它和notify()的功能基本一致，但不同的是，它会唤醒在这个等待队列的所有等待的线程，而不是随机选择一个。</p><p>Object.wait()方法和Object.notify()方法并不是可以随便调用的，它必须包含在对应的synchronized语句中，并且必须先获得目标对象的监视器。需要注意的是：Object.wait()方法和Thread.sleep()方法都可以让线程等待若干时间。除了wait()可以被唤醒外，另外一个主要的区别就是wait()方法会释放目标对象的锁，Thread.sleep()方法不会释放任何资源。</p><h3 id="3-5挂起（suspend）和继续执行（resume）线程"><a href="#3-5挂起（suspend）和继续执行（resume）线程" class="headerlink" title="3.5挂起（suspend）和继续执行（resume）线程"></a>3.5挂起（suspend）和继续执行（resume）线程</h3><p>线程挂起（suspend）和继续执行（resume），这是一对相反的操作，被挂起的线程必须要等到resume()操作后，才能继续执行。因为suspend()方法在导致线程暂停的同时，并不会去释放任何锁资源，所以不推荐使用这个方法。</p><h2 id="4-其它"><a href="#4-其它" class="headerlink" title="4.其它"></a>4.其它</h2><h3 id="4-1等待线程结束（join）和谦让（yield）"><a href="#4-1等待线程结束（join）和谦让（yield）" class="headerlink" title="4.1等待线程结束（join）和谦让（yield）"></a>4.1等待线程结束（join）和谦让（yield）</h3><p>很多时候，一个线程的输入可能非常依赖于另外一个或者多个线程的输出，此时，这个线程就需要等待依赖线程执行完毕，才能继续继续执行，而JDK就是通过join()方法来实现这个功能的。join()方法的本质就是让调用线程wait()在当前线程对象实例上，当线程执行完成后，被等待的线程会在退出前调用notifyAll()通知所有的等待线程继续执行。</p><p>yield()是一个静态方法，一旦执行，它会使当前线程让出CPU，但这里让出CPU并不意味着当前线程不执行了。当前线程在让出CPU后，只是出于就绪状态，还是会继续进行CPU资源的竞争，但是否能被分配到，就不一定了。</p><h3 id="4-2线程组"><a href="#4-2线程组" class="headerlink" title="4.2线程组"></a>4.2线程组</h3><p>在一个系统中，如果线程数量很多，而且功能分配比较明确，就可以将相同功能的线程放置在一个线程组里。</p><h3 id="4-3守护线程（Daemon）"><a href="#4-3守护线程（Daemon）" class="headerlink" title="4.3守护线程（Daemon）"></a>4.3守护线程（Daemon）</h3><p>守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地完成一些系统的服务，比如垃圾回收线程，JIT线程就可以理解为守护线程。线程在实例化后默认为用户线程，可以调用setDaemon(true)方法将目标线程设置为守护线程，但这个设置操作必须先于start()，也就是说要在线程启动前将目标线程设置为守护线程。</p><h3 id="4-4线程优先级"><a href="#4-4线程优先级" class="headerlink" title="4.4线程优先级"></a>4.4线程优先级</h3><p>Java中线程可以有自己的优先级，优先级高的线程在竞争资源时会更有优势，更可能抢占资源，当然，这也只是一个概率的问题。在Java中，使用1到10来表示线程的优先级，可以调用setPriority()方法来设置线程的优先级，但这个设置操作必须先于start()，也就是说要在线程启动前设置好线程的优先级。</p><h3 id="4-5同步锁（synchronized）"><a href="#4-5同步锁（synchronized）" class="headerlink" title="4.5同步锁（synchronized）"></a>4.5同步锁（synchronized）</h3><p>关键字synchronized的作用是实现线程间的同步，它的工作是对同步代码加锁，使得每一次，只能有一个线程进入同步块，从而保证线程间的安全性。synchronized的用法：</p><p>①指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁；</p><p>②直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁；</p><p>③直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁。</p><p>除了用于线程同步、确保线程安全外，synchronized还可以保证线程间的可见性和有序性，并且被synchronized限制的多个线程是串行执行的。</p><p>以上摘自《Java高并发程序设计》一书前两章的部分内容，仅当做笔记作一个记录，省略了书中举的实例。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC和DI简单理解</title>
      <link href="/10009/"/>
      <url>/10009/</url>
      
        <content type="html"><![CDATA[<h2 id="1-IOC是什么"><a href="#1-IOC是什么" class="headerlink" title="1.IOC是什么"></a>1.IOC是什么</h2><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好IOC呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p><p>①谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建；谁控制谁？当然是IOC 容器控制了对象；控制什么？主要控制了程序外部资源的获取（不只是对象包括比如文件等）。</p><p>②为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p><p>IOC是spring的核心，贯穿始终。所谓IOC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p><p>用图例说明一下，传统程序设计如图，都是主动去创建相关对象然后再组合起来：</p><p>传统应用程序示意图<br><img src="/img/backend/ioc_di_01.jpg"></p><p>IOC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p>其实IOC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IOC&#x2F;DI思想中，应用程序就变成被动的了，被动的等待IOC容器来创建并注入它所需要的资源了。IOC很好的体现了面向对象设计法则之一——好莱坞法则：“别找我们，我们找你”；即由IOC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><p>那么IOC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p><p>当有了IOC&#x2F;DI的容器后，在客户端类中不再主动去创建这些对象了，如图所示：<br><img src="/img/backend/ioc_di_02.jpg"></p><h2 id="2-IOC和DI"><a href="#2-IOC和DI" class="headerlink" title="2.IOC和DI"></a>2.IOC和DI</h2><p>DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><p>①谁依赖于谁：当然是应用程序依赖于IOC容器；</p><p>②为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源；</p><p>③谁注入谁：很明显是IOC容器注入应用程序某个对象，应用程序依赖的对象；</p><p>④注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p><p>IOC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IOC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p><p>IOC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><h2 id="3-我对Spring-IOC和DI的理解"><a href="#3-我对Spring-IOC和DI的理解" class="headerlink" title="3.我对Spring IOC和DI的理解"></a>3.我对Spring IOC和DI的理解</h2><p>在我们传统的Java开发当中，如果我们的业务中需要依赖某个外部对象，那么我们就需要在业务代码中通过new的方式主动地去创建这个依赖对象，创建依赖对象的主动权就掌握在自己的手里，创建依赖对象的时机也由自己去把控。而这样的做法就使得对象和对象之间产生了紧密的耦合关系，而通常情况下这都不是我们想要的。</p><p>当我们使用了Spring之后，创建对象的工作就由Spring的IOC容器去完成，当我们的业务中需要使用到某个外部依赖对象时，Spring通过DI的方式把这个依赖对象注入到我们的业务代码当中，我们只要在业务代码中直接使用这个对象就行了。至于Spring容器是怎么创建、何时创建依赖对象的，我们的业务代码并不需要关心，并且依赖对象的生命周期是完全有Spring容器来控制的。</p><p>引入Spring之后，业务在依赖外部对象有一个角色的转变，由主动创建对象变成被动注入对象，对象的控制被反转了。而我们的业务和外部依赖对象之间的关系也由强耦合，变成了松耦合，这才是我们想要的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径（Shortest Path）</title>
      <link href="/10007/"/>
      <url>/10007/</url>
      
        <content type="html"><![CDATA[<h2 id="1-最短路径定义"><a href="#1-最短路径定义" class="headerlink" title="1.最短路径定义"></a>1.最短路径定义</h2><p>从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径叫做最短路径。</p><h2 id="2-dijkstra（单源最短路径算法）"><a href="#2-dijkstra（单源最短路径算法）" class="headerlink" title="2.dijkstra（单源最短路径算法）"></a>2.dijkstra（单源最短路径算法）</h2><p>求单源、无负权的最短路。时效性较好，时间复杂度为O（V<em>V+E）。源点可达的话，O（V</em>lgV+E<em>lgV）&#x3D;&gt;O（E</em>lgV）。当是稀疏图的情况时，此时E&#x3D;V<em>V&#x2F;lgV，所以算法的时间复杂度可为O（V^2）。若是斐波那契堆作优先队列的话，算法时间复杂度，则为O（V</em>lgV + E）。</p><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Grap, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dijkstra</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//图 </span></span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="comment">//源点 </span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="comment">//源点到每一个节点最短的距离 </span></span><br><span class="line">    Weight *distTo;</span><br><span class="line">    <span class="comment">//标记已经找到的节点 </span></span><br><span class="line">    <span class="type">bool</span> *marked;</span><br><span class="line">    <span class="comment">//到的节点是从哪里来的 </span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;*&gt; from;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dijkstra</span>(Graph &amp;graph, <span class="type">int</span> s):<span class="built_in">G</span>(graph) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Weight[G.<span class="built_in">V</span>()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">V</span>(); i++) &#123;</span><br><span class="line">            distTo[i] = <span class="built_in">Weight</span>();</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">            from.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="function">IndexMinHeap&lt;Weight&gt; <span class="title">ipq</span><span class="params">(G.V())</span></span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Dijkstra</span></span><br><span class="line">        distTo[s] = <span class="built_in">Weight</span>();</span><br><span class="line">        marked[s] = <span class="literal">true</span>;</span><br><span class="line">        ipq.<span class="built_in">insert</span>(s, distTo[s]);</span><br><span class="line">        <span class="keyword">while</span> (!ipq.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> v = ipq.<span class="built_in">extractMinIndex</span>();</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//distTo[v] 就是s到v的最短距离</span></span><br><span class="line">            marked[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//松弛操作 </span></span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); e = adj.<span class="built_in">next</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> w = e-&gt;<span class="built_in">other</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (from[w] == <span class="literal">NULL</span> || distTo[v] + e-&gt;<span class="built_in">wt</span>() &lt; distTo[w]) &#123;</span><br><span class="line">                        distTo[w] = distTo[v] + e-&gt;<span class="built_in">wt</span>();</span><br><span class="line">                        from[w] = e;</span><br><span class="line">                        <span class="keyword">if</span> (ipq.<span class="built_in">contain</span>(w)) &#123;</span><br><span class="line">                            ipq.<span class="built_in">change</span>(w, distTo[w]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ipq.<span class="built_in">insert</span>(w, distTo[w]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">Dijkstra</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] distTo;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="function">Weight <span class="title">shortestPathTo</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathTo</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shortestPath</span><span class="params">(<span class="type">int</span> w, vector&lt;Edge&lt;Weight&gt;&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        stack&lt;Edge&lt;Weight&gt;*&gt; s;</span><br><span class="line">        Edge&lt;Weight&gt; *e = from[w];</span><br><span class="line">        <span class="keyword">while</span> (e-&gt;<span class="built_in">v</span>() != e-&gt;<span class="built_in">w</span>()) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(e);</span><br><span class="line">            e = from[e-&gt;<span class="built_in">v</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            e = s.<span class="built_in">top</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*e);</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPath</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>());</span><br><span class="line">         </span><br><span class="line">        vector&lt;Edge&lt;Weight&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">shortestPath</span>(w, vec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cout &lt;&lt; vec[i].<span class="built_in">v</span>() &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == vec.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; vec[i].<span class="built_in">w</span>() &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Bellman-Ford（单源最短路径算法）"><a href="#3-Bellman-Ford（单源最短路径算法）" class="headerlink" title="3.Bellman-Ford（单源最短路径算法）"></a>3.Bellman-Ford（单源最短路径算法）</h2><p>图中不能有负权环，可以判断图中是否有负权环，时间复杂度：O（EV）。如果一个图没有负权环，从一点到另外一点的最短路径，最多经过所有的V个顶线，有V-1条边，否则，存在顶点经过了两次，既存在负权环。</p><p>对一个点的一次松弛操作，就是找到经过这个点的另外一条路径，多一条边，权值更小。如果一个图没有负权边，从一点到另外一点的最短路径，最多经过所有的V个顶线，有个V-1条边，对所有的点进行V-1次松弛操作，理论上可以找到从源点到其他所有点的最短路径。如果还可以继续松弛，所说原图中有负权环。</p><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BellmanFord</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//图 </span></span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="comment">//源点 </span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">     <span class="comment">//源点到每一个节点最短的距离 </span></span><br><span class="line">    Weight* distTo;</span><br><span class="line">    <span class="comment">//到的节点是从哪里来的 </span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;*&gt; from;</span><br><span class="line">    <span class="comment">//图中是否有负权环 </span></span><br><span class="line">    <span class="type">bool</span> hasNegativeCycle;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">detectNegativeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G,i)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>( Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; e = adj.<span class="built_in">next</span>() )</span><br><span class="line">                <span class="keyword">if</span>( !from[e-&gt;<span class="built_in">w</span>()] || distTo[e-&gt;<span class="built_in">v</span>()] + e-&gt;<span class="built_in">wt</span>() &lt; distTo[e-&gt;<span class="built_in">w</span>()] )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BellmanFord</span>(Graph &amp;graph, <span class="type">int</span> s):<span class="built_in">G</span>(graph)&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Weight[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">            from.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Bellman-Ford</span></span><br><span class="line">        distTo[s] = <span class="built_in">Weight</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> pass = <span class="number">1</span> ; pass &lt; G.<span class="built_in">V</span>() ; pass ++ )&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Relaxation</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">                <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G,i)</span></span>;</span><br><span class="line">                <span class="keyword">for</span>( Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; e = adj.<span class="built_in">next</span>() )</span><br><span class="line">                    <span class="keyword">if</span>( !from[e-&gt;<span class="built_in">w</span>()] || distTo[e-&gt;<span class="built_in">v</span>()] + e-&gt;<span class="built_in">wt</span>() &lt; distTo[e-&gt;<span class="built_in">w</span>()] )&#123;</span><br><span class="line">                        distTo[e-&gt;<span class="built_in">w</span>()] = distTo[e-&gt;<span class="built_in">v</span>()] + e-&gt;<span class="built_in">wt</span>();</span><br><span class="line">                        from[e-&gt;<span class="built_in">w</span>()] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        hasNegativeCycle = <span class="built_in">detectNegativeCycle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">BellmanFord</span>()&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span>[] distTo;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">negativeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasNegativeCycle;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Weight <span class="title">shortestPathTo</span><span class="params">( <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( !hasNegativeCycle );</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathTo</span><span class="params">( <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="keyword">return</span> from[w] != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shortestPath</span><span class="params">( <span class="type">int</span> w, vector&lt;Edge&lt;Weight&gt;&gt; &amp;vec )</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( !hasNegativeCycle );</span><br><span class="line"> </span><br><span class="line">        stack&lt;Edge&lt;Weight&gt;*&gt; s;</span><br><span class="line">        Edge&lt;Weight&gt; *e = from[w];</span><br><span class="line">        <span class="keyword">while</span>( e-&gt;<span class="built_in">v</span>() != <span class="keyword">this</span>-&gt;s )&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(e);</span><br><span class="line">            e = from[e-&gt;<span class="built_in">v</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(e);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>( !s.<span class="built_in">empty</span>() )&#123;</span><br><span class="line">            e = s.<span class="built_in">top</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>( *e );</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPath</span><span class="params">(<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( !hasNegativeCycle );</span><br><span class="line"> </span><br><span class="line">        vector&lt;Edge&lt;Weight&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">shortestPath</span>(w, vec);</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; vec.<span class="built_in">size</span>() ; i ++ )&#123;</span><br><span class="line">            cout&lt;&lt;vec[i].<span class="built_in">v</span>()&lt;&lt;<span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>( i == vec.<span class="built_in">size</span>()<span class="number">-1</span> )</span><br><span class="line">                cout&lt;&lt;vec[i].<span class="built_in">w</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 搜索问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论（Graph Theory）</title>
      <link href="/10006/"/>
      <url>/10006/</url>
      
        <content type="html"><![CDATA[<h2 id="1-图论的定义"><a href="#1-图论的定义" class="headerlink" title="1.图论的定义"></a>1.图论的定义</h2><p>图论〔Graph Theory〕是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。由节点（Vertex）和边（Edge）构造而成的模型，可分为无向图（Undirected Graph）和有向图（Directed Graph），无向图是一种特殊的有向图。从另外一个角度可分为无权图（Unweighted Graph）和有权图（Weighted Graph），有权图表示节点和节点之间的边需要一个值和它对应起来。</p><h2 id="2-图的表示"><a href="#2-图的表示" class="headerlink" title="2.图的表示"></a>2.图的表示</h2><h3 id="2-1邻接矩阵（Adjacency-Matirx）"><a href="#2-1邻接矩阵（Adjacency-Matirx）" class="headerlink" title="2.1邻接矩阵（Adjacency Matirx）"></a>2.1邻接矩阵（Adjacency Matirx）</h3><p>邻接矩阵适合表示稠密图（Dese Graph），边远远少于最大的边数。</p><h3 id="2-2邻接表（Adjacency-Lists）"><a href="#2-2邻接表（Adjacency-Lists）" class="headerlink" title="2.2邻接表（Adjacency Lists）"></a>2.2邻接表（Adjacency Lists）</h3><p>邻接表适合表示稀疏图（Spare Graph），每个点都相连接。</p><h2 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3.基本操作"></a>3.基本操作</h2><h3 id="3-1邻接矩阵"><a href="#3-1邻接矩阵" class="headerlink" title="3.1邻接矩阵"></a>3.1邻接矩阵</h3><h4 id="3-1-1数据结构"><a href="#3-1-1数据结构" class="headerlink" title="3.1.1数据结构"></a>3.1.1数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//稠密图 - 邻接矩阵</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DenseGraph</span> &#123;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//存放点数和边数 </span></span><br><span class="line">    <span class="type">bool</span> directed;<span class="comment">//有向图或无向图 </span></span><br><span class="line">    vector&lt; vector&lt;<span class="type">bool</span>&gt; &gt; g;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DenseGraph</span>(<span class="type">int</span> n, <span class="type">bool</span> directed) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2添加一条边"><a href="#3-1-2添加一条边" class="headerlink" title="3.1.2添加一条边"></a>3.1.2添加一条边</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">    <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hasEdge</span>(v, w)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    g[v][w] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!directed) &#123;</span><br><span class="line">        g[w][v] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    m ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3判断边是否在图内"><a href="#3-1-3判断边是否在图内" class="headerlink" title="3.1.3判断边是否在图内"></a>3.1.3判断边是否在图内</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">    <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> g[v][w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-4迭代器"><a href="#3-1-4迭代器" class="headerlink" title="3.1.4迭代器"></a>3.1.4迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">adjIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DenseGraph &amp;G;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">adjIterator</span>(DenseGraph &amp;graph, <span class="type">int</span> v): <span class="built_in">G</span>(graph) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;index= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//开始节点 </span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index = <span class="number">-1</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//下一个节点 </span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (index += <span class="number">1</span>; index &lt; G.<span class="built_in">V</span>(); index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (G.g[v][index]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//是否还有节点 </span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt;= G.<span class="built_in">V</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2邻接表"><a href="#3-2邻接表" class="headerlink" title="3.2邻接表"></a>3.2邻接表</h3><h4 id="3-2-1数据结构"><a href="#3-2-1数据结构" class="headerlink" title="3.2.1数据结构"></a>3.2.1数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//疏密图 - 邻接表 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SparseGraph</span> &#123;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">bool</span> directed;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; g;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SparseGraph</span>(<span class="type">int</span> n, <span class="type">bool</span> directed) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2添加一条边"><a href="#3-2-2添加一条边" class="headerlink" title="3.2.2添加一条边"></a>3.2.2添加一条边</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">    <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">     </span><br><span class="line">    g[v].<span class="built_in">push_back</span>(w);</span><br><span class="line">    <span class="keyword">if</span> (v != w &amp;&amp; !directed) &#123;</span><br><span class="line">        g[w].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    m++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3判断边是否在图内"><a href="#3-2-3判断边是否在图内" class="headerlink" title="3.2.3判断边是否在图内"></a>3.2.3判断边是否在图内</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">    <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[v][i] == w) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4迭代器"><a href="#3-2-4迭代器" class="headerlink" title="3.2.4迭代器"></a>3.2.4迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">adjIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SparseGraph &amp;G;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">adjIterator</span>(SparseGraph &amp;graph, <span class="type">int</span> v): <span class="built_in">G</span>(graph) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;index= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//开始节点 </span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (G.g[v].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//下一个节点 </span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; G.g[v].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//是否还有节点 </span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt;= G.g[v].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-图的遍历"><a href="#4-图的遍历" class="headerlink" title="4.图的遍历"></a>4.图的遍历</h2><h3 id="4-1深度优先遍历"><a href="#4-1深度优先遍历" class="headerlink" title="4.1深度优先遍历"></a>4.1深度优先遍历</h3><p>从一个节点开始，不停的向下试，直到没有节点与它相连为止</p><h4 id="4-1-1深度优先遍历实现"><a href="#4-1-1深度优先遍历实现" class="headerlink" title="4.1.1深度优先遍历实现"></a>4.1.1深度优先遍历实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="type">bool</span> * visited;<span class="comment">//是否被访问过 </span></span><br><span class="line">    <span class="type">int</span> ccount;<span class="comment">//记录有几个连通分量 </span></span><br><span class="line">    <span class="type">int</span> * id;<span class="comment">//记录两个点是否相连 </span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//深度优先遍历 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        id[ccount];</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); i = adj.<span class="built_in">next</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Component</span>(Graph &amp;graph): <span class="built_in">G</span>(graph) &#123;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="type">int</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        ccount = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">V</span>(); i++) &#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            id[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">V</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">                ccount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">Component</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] visited;</span><br><span class="line">        <span class="keyword">delete</span> [] id;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//返回连通分量 </span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ccount;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//v和w是否相连接 </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; G.<span class="built_in">V</span>());</span><br><span class="line">        <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-1-2利用深度优先遍历寻找路径"><a href="#4-1-2利用深度优先遍历寻找路径" class="headerlink" title="4.1.2利用深度优先遍历寻找路径"></a>4.1.2利用深度优先遍历寻找路径</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找一条从s开始的路径 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Path</span> &#123;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">bool</span> * visited;</span><br><span class="line">    <span class="comment">//保存上一个访问的节点 </span></span><br><span class="line">    <span class="type">int</span> * from;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//深度优先搜索 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); i = adj.<span class="built_in">next</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                from[i] = v;</span><br><span class="line">                 </span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Path</span>(Graph &amp;graph, <span class="type">int</span> s): <span class="built_in">G</span>(graph) &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">assert</span>(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.<span class="built_in">V</span>());</span><br><span class="line">         </span><br><span class="line">        visited = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="type">int</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">V</span>(); i++) &#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//寻路算法 </span></span><br><span class="line">        <span class="built_in">dfs</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">Path</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] visited;</span><br><span class="line">        <span class="keyword">delete</span> [] from;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//w是否在路径中 </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//构建从s到w的路径 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">path</span><span class="params">(<span class="type">int</span> w, vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//展示从s到w的路径 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPath</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="built_in">path</span>(w, vec);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cout &lt;&lt; vec[i];</span><br><span class="line">            <span class="keyword">if</span> (i == vec.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-1-3图的深度优先遍历复杂度"><a href="#4-1-3图的深度优先遍历复杂度" class="headerlink" title="4.1.3图的深度优先遍历复杂度"></a>4.1.3图的深度优先遍历复杂度</h4><p>稀疏图（邻接表）：O（V+E）</p><p>稠密图（邻接矩阵）：O（V2）</p><h3 id="4-2广度优先遍历"><a href="#4-2广度优先遍历" class="headerlink" title="4.2广度优先遍历"></a>4.2广度优先遍历</h3><h4 id="4-2-1广度优先遍历实现"><a href="#4-2-1广度优先遍历实现" class="headerlink" title="4.2.1广度优先遍历实现"></a>4.2.1广度优先遍历实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先搜索 </span></span><br><span class="line"><span class="comment">//求无权图最短路径</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShortestPath</span> &#123;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="comment">//是否被访问过 </span></span><br><span class="line">    <span class="type">bool</span> * visited;</span><br><span class="line">    <span class="comment">//保存上一个访问的节点 </span></span><br><span class="line">    <span class="type">int</span> * from;</span><br><span class="line">    <span class="comment">//s到每一个节点的最短距离 </span></span><br><span class="line">    <span class="type">int</span> * ord;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShortestPath</span>(Graph &amp;graph, <span class="type">int</span> s): <span class="built_in">G</span>(graph) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; graph.<span class="built_in">V</span>());</span><br><span class="line">         </span><br><span class="line">        visited = <span class="keyword">new</span> <span class="type">bool</span>[graph.<span class="built_in">V</span>()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="type">int</span>[graph.<span class="built_in">V</span>()];</span><br><span class="line">        ord = <span class="keyword">new</span> <span class="type">int</span>[graph.<span class="built_in">V</span>()];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">V</span>(); i++) &#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">            ord[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">         </span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="comment">//无向图最短路径算法</span></span><br><span class="line">       q.<span class="built_in">push</span>(s);</span><br><span class="line">       visited[s] = <span class="literal">true</span>;</span><br><span class="line">       ord[s] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">           <span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">           q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">           <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); i = adj.<span class="built_in">next</span>()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                   q.<span class="built_in">push</span>(i);</span><br><span class="line">                   visited[i] = <span class="literal">true</span>;</span><br><span class="line">                   from[i] = v;</span><br><span class="line">                   ord[i] = ord[v] + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">ShortestPath</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] visited;</span><br><span class="line">        <span class="keyword">delete</span> [] from;</span><br><span class="line">        <span class="keyword">delete</span> [] ord;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//w是否在路径中 </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//构建从s到w的路径 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">path</span><span class="params">(<span class="type">int</span> w, vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//展示从s到w的路径 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPath</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="built_in">path</span>(w, vec);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cout &lt;&lt; vec[i];</span><br><span class="line">            <span class="keyword">if</span> (i == vec.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//s到w的最短路径 </span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> ord[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-2-2图的深度优先遍历复杂度"><a href="#4-2-2图的深度优先遍历复杂度" class="headerlink" title="4.2.2图的深度优先遍历复杂度"></a>4.2.2图的深度优先遍历复杂度</h4><p>稀疏图（邻接表）：O（V+E）</p><p>稠密图（邻接矩阵）：O（V2）</p><h2 id="5-有权图"><a href="#5-有权图" class="headerlink" title="5.有权图"></a>5.有权图</h2><p>所谓有权图，就是图中的每一条边上都会有相应的一个或一组值。</p><h3 id="5-1有权图的实现"><a href="#5-1有权图的实现" class="headerlink" title="5.1有权图的实现"></a>5.1有权图的实现</h3><h4 id="5-1-1用Edge来表示边"><a href="#5-1-1用Edge来表示边" class="headerlink" title="5.1.1用Edge来表示边"></a>5.1.1用Edge来表示边</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用一个模板类来表示边 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//边的顶点 </span></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">//边的权值 </span></span><br><span class="line">    Weight weight;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> a, <span class="type">int</span> b, Weight weight) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">Edge</span>() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">Edge</span>() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">v</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">w</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function">Weight <span class="title">wt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//知道一个顶点，获取另外一个顶点 </span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">other</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x == a || x == b);</span><br><span class="line">        <span class="keyword">return</span> x == a ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//重载&lt;&lt; </span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Edge &amp;e) &#123;</span><br><span class="line">        os &lt;&lt; e.a &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; e.b &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; e.weight;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//重载比较运算符 </span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt;= e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt; e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt;= e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight == e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载比较运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-1-2邻接矩阵（稠密图）"><a href="#5-1-2邻接矩阵（稠密图）" class="headerlink" title="5.1.2邻接矩阵（稠密图）"></a>5.1.2邻接矩阵（稠密图）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//稠密图 - 邻接矩阵</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DenseGraph</span> &#123;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//存放点数和边数 </span></span><br><span class="line">    <span class="type">bool</span> directed;<span class="comment">//有向图或无向图 </span></span><br><span class="line">    vector&lt; vector&lt;Edge&lt;Weight&gt; *&gt; g;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DenseGraph</span>(<span class="type">int</span> n, <span class="type">bool</span> directed) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.<span class="built_in">push_back</span>(vector&lt;Edge&lt;Weight&gt; *&gt;(n, <span class="literal">NULL</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">DenseGraph</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] != <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">delete</span> g[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w, Weight weight)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hasEdge</span>(v, w)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> g[v][w];</span><br><span class="line">            <span class="keyword">if</span> (!directed) &#123;</span><br><span class="line">                <span class="keyword">delete</span> g[w][v];</span><br><span class="line">            &#125;</span><br><span class="line">            m --;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        g[v][w] = <span class="keyword">new</span> <span class="built_in">Edge</span>&lt;Weight&gt;(v, w, weight);</span><br><span class="line">        <span class="keyword">if</span> (!directed) &#123;</span><br><span class="line">            g[w][v] = <span class="keyword">new</span> <span class="built_in">Edge</span>&lt;Weight&gt;(w, v, weight);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> g[v][w] != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j]) &#123;</span><br><span class="line">                    cout &lt;&lt; g[i][j]-&gt;<span class="built_in">wt</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;NULL\t&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">adjIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DenseGraph &amp;G;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">adjIterator</span>(DenseGraph &amp;graph, <span class="type">int</span> v): <span class="built_in">G</span>(graph) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;index= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//开始节点 </span></span><br><span class="line">        <span class="function">Edge&lt;Weight&gt; * <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index = <span class="number">-1</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//下一个节点 </span></span><br><span class="line">        <span class="function">Edge&lt;Weight&gt; * <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (index += <span class="number">1</span>; index &lt; G.<span class="built_in">V</span>(); index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (G.g[v][index]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//是否还有节点 </span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt;= G.<span class="built_in">V</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-1-3邻接表（稀疏图）"><a href="#5-1-3邻接表（稀疏图）" class="headerlink" title="5.1.3邻接表（稀疏图）"></a>5.1.3邻接表（稀疏图）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//疏密图 - 邻接表 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SparseGraph</span> &#123;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">bool</span> directed;</span><br><span class="line">    vector&lt; vector&lt;Edge&lt;Weight&gt; *&gt; &gt; g;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SparseGraph</span>(<span class="type">int</span> n, <span class="type">bool</span> directed) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.<span class="built_in">push_back</span>(vector&lt;Edge&lt;Weight&gt; *&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">SparseGraph</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> g[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w, Weight weight)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">         </span><br><span class="line">        g[v].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Edge</span>(v, w, weight));</span><br><span class="line">        <span class="keyword">if</span> (v != w &amp;&amp; !directed) &#123;</span><br><span class="line">            g[w].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Edge</span>(w, v, weight));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        m++; </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        <span class="built_in">assert</span>(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[v][i]-&gt;<span class="built_in">other</span>(v) == w) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;vertex&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:\t&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;( to:&quot;</span> &lt;&lt; g[i][j]-&gt;<span class="built_in">w</span>() &lt;&lt; <span class="string">&quot;,wt:&quot;</span> &lt;&lt; g[i][j]-&gt;<span class="built_in">wt</span>() &lt;&lt; <span class="string">&quot;)\t&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">adjIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SparseGraph &amp;G;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">adjIterator</span>(SparseGraph &amp;graph, <span class="type">int</span> v): <span class="built_in">G</span>(graph) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;index= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//开始节点 </span></span><br><span class="line">        <span class="function">Edge&lt;Weight&gt; * <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (G.g[v].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//下一个节点 </span></span><br><span class="line">        <span class="function">Edge&lt;Weight&gt; * <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; G.g[v].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//是否还有节点 </span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt;= G.g[v].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2最小生成树"><a href="#5-2最小生成树" class="headerlink" title="5.2最小生成树"></a>5.2最小生成树</h3><h4 id="5-2-1利用切分定理实现最小生成树"><a href="#5-2-1利用切分定理实现最小生成树" class="headerlink" title="5.2.1利用切分定理实现最小生成树"></a>5.2.1利用切分定理实现最小生成树</h4><p>切分（Cut）：把图中的节点分为两部分，成为一个切分（Cut）。</p><p>横切边（Crossing Edge）：如果一个边的两个端点，属于切分（Cut）不同的两边，这个边称为横切边（Crossing Edge）。</p><p>切分定理（Cut Property）：给定任意切分，横切边中权值最小的边必然属于最小生成树。</p><p>①Lazy Prim（时间复杂度：O（ElogE））</p><p>最小堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item* data;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; data[k / <span class="number">2</span>] &gt; data[k]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(data[k / <span class="number">2</span>], data[k]);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span> * k;<span class="comment">//在此轮循环中，data[k]和data[j]交换位置</span></span><br><span class="line">           <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[j + <span class="number">1</span>] &lt; data[j]) &#123;</span><br><span class="line">               j += <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (data[k] &lt;= data[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="built_in">swap</span>(data[k], data[j]);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinHeap</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity + <span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">MinHeap</span>(Item arr[], <span class="type">int</span> n) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            data[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        count = n;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = count / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">shiftDown</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">MaxHeap</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] data;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        data[count + <span class="number">1</span>] = item;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">shiftUp</span>(count);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function">Item <span class="title">extractMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(count &gt; <span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">swap</span>(data[<span class="number">1</span>], data[count]);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Lazy Prim实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazyPrimMST</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    MinHeap&lt;Edge&lt;Weight&gt;&gt; pq;</span><br><span class="line">    <span class="type">bool</span> *marked;</span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; mst;</span><br><span class="line">    Weight mstWeight;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(!marked[v]);</span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;Weight)* e = adg.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); e = adj.<span class="built_in">next</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (marked[e-&gt;<span class="built_in">other</span>(v)]) &#123;</span><br><span class="line">                pq.<span class="built_in">insert</span>(*e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LazyPrimMST</span>(Graph &amp;graph):<span class="built_in">G</span>(graph), <span class="built_in">pq</span>(MinHeap&lt;Edge&lt;Weight&gt;&gt;(graph.<span class="built_in">E</span>())) &#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">V</span>(); i++) &#123;</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mst.<span class="built_in">clear</span>();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//lazy Prim</span></span><br><span class="line">       <span class="built_in">visit</span>(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">while</span> (!pq.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">           Edge&lt;Weight&gt; e = pq.<span class="built_in">extractMin</span>();</span><br><span class="line">           <span class="keyword">if</span> (marked[e.<span class="built_in">v</span>()] == marked[e.<span class="built_in">w</span>()]) &#123;</span><br><span class="line">               <span class="keyword">continue</span> ;</span><br><span class="line">           &#125;</span><br><span class="line">           mst.<span class="built_in">push_back</span>(e);</span><br><span class="line">           <span class="keyword">if</span> (!marked[e.<span class="built_in">v</span>()]) &#123;</span><br><span class="line">               <span class="built_in">visit</span>(e.<span class="built_in">v</span>());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="built_in">visit</span>(e.<span class="built_in">w</span>());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       mstWeight = mst[<span class="number">0</span>].<span class="built_in">wt</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; mst.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">           mstWeight += mst[i].<span class="built_in">wt</span>();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">LazyPrimMST</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; <span class="built_in">mstEdge</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function">Weight <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>②Prim（时间复杂度：O（ElogV））</p><p>最小索引堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexMinHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item* data;</span><br><span class="line">    <span class="type">int</span>* indexes;</span><br><span class="line">    <span class="type">int</span>* reverse;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k / <span class="number">2</span>]] &gt; data[indexes[[k]]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(indexes[k / <span class="number">2</span>], indexes[k]);</span><br><span class="line">            reverse[indexes[k / <span class="number">2</span>]] = k / <span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span> * k;<span class="comment">//在此轮循环中，data[k]和data[j]交换位置</span></span><br><span class="line">           <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j + <span class="number">1</span>]] &gt; data[indexes[j]]) &#123;</span><br><span class="line">               j += <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (data[indexes[k]] &lt;= data[indexes[j]]) &#123;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="built_in">swap</span>(indexes[k], indexes[j]);</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            reverse[indexes[j]] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IndexMinHeap</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity + <span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="type">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="type">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">IndexMinHeap</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] data;</span><br><span class="line">        <span class="keyword">delete</span> [] indexes;</span><br><span class="line">        <span class="keyword">delete</span> [] reverse;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//传入的i对用户而言，是从0开始的 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, Item item)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        <span class="built_in">assert</span>(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity); </span><br><span class="line">         </span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count + <span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count + <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">shiftUp</span>(count);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function">Item <span class="title">extractMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(count &gt; <span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        <span class="built_in">swap</span>(indexes[<span class="number">1</span>], indexes[count]);</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(count &gt; <span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(indexes[<span class="number">1</span>], indexes[count]);</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contain</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        <span class="keyword">return</span> reverse[i + <span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">contain</span>(i));</span><br><span class="line">        <span class="keyword">return</span> data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> i, Item newItem)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">contain</span>(i));</span><br><span class="line">         </span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        data[i] = newItem;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//找到indexes[j] = i,j表示data[i]在堆中的位置</span></span><br><span class="line">       <span class="comment">//之后shiftUp(j),再shiftDown(j)</span></span><br><span class="line">       <span class="comment">/*for (int j = 1; i &lt;= count; j++) &#123;</span></span><br><span class="line"><span class="comment">           if (indexes[j] == i) &#123;</span></span><br><span class="line"><span class="comment">                shiftUp(j);</span></span><br><span class="line"><span class="comment">               shiftDown(j);</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">               return ;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">       &#125;*/</span></span><br><span class="line">        </span><br><span class="line">       <span class="type">int</span> j = reverse[i];</span><br><span class="line">       <span class="built_in">shiftUp</span>(j);</span><br><span class="line">       <span class="built_in">shiftDown</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Prim实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrimMST</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    IndexMinHeap&lt;Edge&lt;Weight&gt;&gt; ipq;</span><br><span class="line">    <span class="comment">//和每个节点相连的最小的横切边 </span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;*&gt; edgeTo;</span><br><span class="line">    <span class="comment">//点属于哪个切分 </span></span><br><span class="line">    <span class="type">bool</span> *marked;</span><br><span class="line">    <span class="comment">//最小生成树所有的边 </span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; mst;</span><br><span class="line">    <span class="comment">//最小生成树的权值大小 </span></span><br><span class="line">    Weight mstWeight;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(!marked[v]);</span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;Weight)* e = adg.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); e = adj.<span class="built_in">next</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> w = e-&gt;<span class="built_in">other</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!edgeTo[w]) &#123;</span><br><span class="line">                    ipq.<span class="built_in">insert</span>(w, e-&gt;<span class="built_in">wt</span>());</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;<span class="built_in">wt</span>() &lt; edgeTo[w]-&gt;<span class="built_in">wt</span>()) &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.<span class="built_in">change</span>(w, e-&gt;<span class="built_in">wt</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LazyPrimMST</span>(Graph &amp;graph):<span class="built_in">G</span>(graph), <span class="built_in">pq</span>(MinHeap&lt;Edge&lt;Weight&gt;&gt;(graph.<span class="built_in">E</span>())) &#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">V</span>(); i++) &#123;</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">            edegeTo.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mst.<span class="built_in">clear</span>();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Prim</span></span><br><span class="line">       <span class="built_in">visit</span>(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">while</span> (!ipq.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">           <span class="type">int</span> v = ipg.<span class="built_in">extractMinIndex</span>();</span><br><span class="line">           <span class="built_in">assert</span>(edgeTo[v]);</span><br><span class="line">           mst.<span class="built_in">push_back</span>(*edgeTo[v]);</span><br><span class="line">           <span class="built_in">visit</span>(v);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       mstWeight = mst[<span class="number">0</span>].<span class="built_in">wt</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; mst.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">           mstWeight += mst[i].<span class="built_in">wt</span>();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">LazyPrimMST</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; <span class="built_in">mstEdge</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function">Weight <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-2-2利用Kruskal算法实现最小生成树"><a href="#5-2-2利用Kruskal算法实现最小生成树" class="headerlink" title="5.2.2利用Kruskal算法实现最小生成树"></a>5.2.2利用Kruskal算法实现最小生成树</h4><p>先将图中所有的边进行升序排序，然后从小到大取边，只要取得的边不会与原来的最小生成树构成环，那么就将两点加入到最小生成树中，直到取到了V-1条边，即构成了最小生成树。（时间复杂度：O（ElogE））</p><p>并查集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* parent;</span><br><span class="line">    <span class="type">int</span>* rank;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> count) &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">UnionFind</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] parent;</span><br><span class="line">        <span class="keyword">delete</span> [] rank;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="type">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (rank[pRoot] &lt; rank[qRoot]) &#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[qRoot] &lt; rank[pRoot]) &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//rank[pRoot] == rank[qRoot] </span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Kruskal实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KruskalMST</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; mst;</span><br><span class="line">    Weight mstWeight;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KruskalMST</span>(Graph &amp;graph) &#123;</span><br><span class="line">        MinHeap&lt;Edge&lt;Weight&gt;&gt; <span class="built_in">pq</span>(graph.<span class="built_in">E</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">V</span>(); i++) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(graph, i)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (Edge&lt;Weight&gt; *e = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); e = adj.<span class="built_in">next</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e-&gt;<span class="built_in">v</span>() &lt; e-&gt;<span class="built_in">w</span>()) &#123;</span><br><span class="line">                    pq.<span class="built_in">insert</span>(*e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(graph.V())</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">isEmpty</span>() &amp;&amp; mst.<span class="built_in">size</span>() &lt; graph.<span class="built_in">v</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            Edge&lt;Weight&gt; e = pq.<span class="built_in">extractMin</span>();</span><br><span class="line">            <span class="keyword">if</span> (uf.<span class="built_in">isConnected</span>(e.<span class="built_in">v</span>(), e.<span class="built_in">w</span>())) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            mst.<span class="built_in">push_back</span>(e);</span><br><span class="line">            uf.<span class="built_in">unionElements</span>(e.<span class="built_in">v</span>(), e.<span class="built_in">w</span>()); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       mstWeight = mst[<span class="number">0</span>].<span class="built_in">wt</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; mst.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">           mstWeight += mst[i].<span class="built_in">wt</span>();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">KruskalMST</span>() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; <span class="built_in">mstEdge</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function">Weight <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树（Binary Search Tree）</title>
      <link href="/10003/"/>
      <url>/10003/</url>
      
        <content type="html"><![CDATA[<h2 id="1-二叉搜索树的定义"><a href="#1-二叉搜索树的定义" class="headerlink" title="1.二叉搜索树的定义"></a>1.二叉搜索树的定义</h2><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。<br><img src="/img/backend/Binary_search_tree.svg.png"></p><h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h2><p>二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索,插入,删除的复杂度等于树高，O(log(n))。</p><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h2><p>①高效：不仅可以查找数据，还可以高效地插入、删除数据（动态的维护数据）；</p><table><thead><tr><th>数据结构\操作</th><th>查找元素</th><th>插入元素</th><th>删除元素</th></tr></thead><tbody><tr><td>普通数组</td><td>O（n）</td><td>O（n）</td><td>O（n）</td></tr><tr><td>顺序数组</td><td>O（logn）</td><td>O（n）</td><td>O（n）</td></tr><tr><td>二分搜索树</td><td>O（logn）</td><td>O（logn）</td><td>O（logn）</td></tr></tbody></table><p>②可以方便地回答很多数据之间的问题：min（最小值），max（最大值），floor（第一次出现的位置），ceil（最后一次出现的位置），rank（排名），select（选择问题）；</p><p>③二叉搜索树首先是一棵二叉树，并且每个节点的键值大于左孩子，每个节点的键值小于右孩子，以左右孩子节点为根的子树仍为二分搜索树，并且二分搜索树不一定是完全二叉树。</p><h2 id="4-二叉搜索树的基本操作"><a href="#4-二叉搜索树的基本操作" class="headerlink" title="4.二叉搜索树的基本操作"></a>4.二叉搜索树的基本操作</h2><h3 id="4-1数据结构"><a href="#4-1数据结构" class="headerlink" title="4.1数据结构"></a>4.1数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key:键;value:值 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        <span class="comment">//左孩子节点 </span></span><br><span class="line">        Node *left;</span><br><span class="line">        <span class="comment">//右孩子节点 </span></span><br><span class="line">        Node *right;</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">Node</span>(Key key, Value value) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//复制一个节点 </span></span><br><span class="line">        <span class="built_in">Node</span>(Node* node) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = node-&gt;key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = node-&gt;value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = node-&gt;left;</span><br><span class="line">            <span class="keyword">this</span>-&gt;right = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//根节点 </span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="comment">//节点数 </span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2插入（Insert）"><a href="#4-2插入（Insert）" class="headerlink" title="4.2插入（Insert）"></a>4.2插入（Insert）</h3><p>时间复杂度：O（logn）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向以node为根的二叉树搜索树中，插入节点(key, value)</span></span><br><span class="line"><span class="comment">//返回插入新节点本身 </span></span><br><span class="line"><span class="function">Node* <span class="title">insert</span><span class="params">(Node* node, Key key, Value value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        count++ ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (key == node-&gt;key) &#123;</span><br><span class="line">        node-&gt;value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = <span class="built_in">insert</span>(node-&gt;left, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//key &gt; node-&gt;key</span></span><br><span class="line">        node-&gt;right = <span class="built_in">insert</span>(node-&gt;right, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3查找（Search）"><a href="#4-3查找（Search）" class="headerlink" title="4.3查找（Search）"></a>4.3查找（Search）</h3><p>时间复杂度：O（logn）</p><p>①是否存在某个key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看以node为根的二叉树中是否包含键值为key的节点 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contain</span><span class="params">(Node* node, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (key == node-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">contain</span>(node-&gt;left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">contain</span>(node-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②查找键对应的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在以node为根的二叉树中查找key所对应的value </span></span><br><span class="line"><span class="function">Value* <span class="title">search</span><span class="params">(Node* node, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (key == node-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;left, key); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4深度优先遍历"><a href="#4-4深度优先遍历" class="headerlink" title="4.4深度优先遍历"></a>4.4深度优先遍历</h3><p>每次走到最深，再回溯。时间复杂度：O（n）</p><p>①前序遍历：先访问当前节点，再依次递归访问左右子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对以node为根的二叉搜索树进行前序遍历 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; node-&gt;key &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②中序遍历：先访问左子树，再访问当前及节点，再递归访问左子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对以node为根的二叉搜索树进行中序遍历 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;left);</span><br><span class="line">        cout &lt;&lt; node-&gt;key &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③后续遍历：先访问左右子树，再访问自身节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对以node为根的二叉搜索树进行后序遍历 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;right);</span><br><span class="line">        cout &lt;&lt; node-&gt;key &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5广度优先遍历（层序）"><a href="#4-5广度优先遍历（层序）" class="headerlink" title="4.5广度优先遍历（层序）"></a>4.5广度优先遍历（层序）</h3><p>利用队列，进行层序遍历，先将根节点入队，然后开始遍历队列：</p><p>①取出队首元素作为当前元素，再将当前元素的左右子节点依次放入队列；</p><p>②重复①操作直到队列为空。</p><p>时间复杂度：O（n）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">         </span><br><span class="line">        cout &lt;&lt; node-&gt;key &lt;&lt; endl;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6最值"><a href="#4-6最值" class="headerlink" title="4.6最值"></a>4.6最值</h3><p>时间复杂度：O（logn）</p><p>①最小值：从根节点开始，沿着左孩子一直向下查找，每次都访问节点的左孩子，直到找到一个节点没有左孩子，那么此节点为最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对以node为根的二叉搜索树查找最小值 </span></span><br><span class="line"><span class="function">Node* <span class="title">minimum</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">minimum</span>(node-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②最大值：从根节点开始，沿着右孩子一直向下查找，每次都访问节点的右孩子，直到找到一个节点没有右孩子，那么此节点为最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对以node为根的二叉搜索树查找最大值 </span></span><br><span class="line"><span class="function">Node* <span class="title">maxmum</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">maxmum</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7删除（Delete）"><a href="#4-7删除（Delete）" class="headerlink" title="4.7删除（Delete）"></a>4.7删除（Delete）</h3><p>时间复杂度：O（logn）</p><p>①删除最小值：因为最小值所在的节点没有左孩子，找到最小值后，先获取最小值的右孩子，然后直接删除最小值，无论右孩子是否为空都直接返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除以node为根的二分搜索树种的最小节点</span></span><br><span class="line"><span class="comment">//返回删除节点后新的二分搜索树</span></span><br><span class="line"><span class="function">Node* <span class="title">removeMin</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* rightNode = node-&gt;right;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    node-&gt;left = <span class="built_in">removeMin</span>(node-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②删除最大值：以为最大值所在的节点没有右孩子，找到最大值后，先获取最大值的左孩子，然后直接删除最大值，无论左孩子是否为空都直接返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//删除以node为根的二分搜索树种的最大节点</span><br><span class="line">//返回删除节点后新的二分搜索树</span><br><span class="line">Node* removeMax(Node* node) &#123;</span><br><span class="line">    if (node-&gt;right == NULL) &#123;</span><br><span class="line">        Node* leftNode = node-&gt;left;</span><br><span class="line">        delete node;</span><br><span class="line">        count--;</span><br><span class="line">        return leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    node-&gt;right = removeMin(node-&gt;right);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③删除任意节点：先找到要删除的节点d，如果d的左孩子为空，先获取到d的右孩子，然后直接删除d，无论右孩子是否为空都直接返回；如果d的右孩子为空，先获取到d的左孩子，然后直接删除d，无论左孩子是否为空都直接返回；如果d的左右孩子都不为空，那我们可以使用Hubbard Deletion算法，先找到d的后继节点（指的是d的下一个节点，既满足比d左孩子大且比d右孩子小的节点）来代替d的位置，d的后继节点可以是d左子树的最大值，也可以是d右子树的最小值，这里我们取右子树的最小值作为d的后继节点s，然后s取d右子树最小值的副本（因为d右子树的最小值要被删除，所以复制一份），接着删除d右子树的最小值并将返回的根节点作为s的右孩子，s的左孩子指向d的左孩子，最后删除d并返回s节点。删除任意节点操作完成，过程略微的复杂，可结合下面的代码实现来理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除掉以node为根的二分搜索树中键值为key的节点</span></span><br><span class="line"><span class="comment">//返回删除节点后新的二分搜索树的根 </span></span><br><span class="line"><span class="function">Node* <span class="title">remove</span><span class="params">(Node* node, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = <span class="built_in">remove</span>(node-&gt;left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = <span class="built_in">remove</span>(node-&gt;right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node* rightNode = node-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node* leftNode = node-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//node-&gt;left != NULL &amp;&amp; node-&gt;right != NULL</span></span><br><span class="line">        Node* successor = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="built_in">minimum</span>(node-&gt;right));</span><br><span class="line">        <span class="comment">//这里等于是新增了一个元素，所以要count++ </span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//删除右子树中最小的元素 </span></span><br><span class="line">        successor-&gt;right = <span class="built_in">removeMin</span>(node-&gt;right);</span><br><span class="line">        successor-&gt;left = node-&gt;left;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        count--;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 树 </tag>
            
            <tag> 搜索问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树（Binary Tree）</title>
      <link href="/10005/"/>
      <url>/10005/</url>
      
        <content type="html"><![CDATA[<h2 id="1-树的概念"><a href="#1-树的概念" class="headerlink" title="1.树的概念"></a>1.树的概念</h2><p>①子节点和父节点（是相对定义的）：一棵树的根节点称为该树的子树的根节点的父节点，子树的根是树根的子节点；</p><p>②边：从父节点到子节点的连线（边有方向）；</p><p>③兄弟节点：父节点相同的节点互为兄弟节点；</p><p>④树叶、分支节点：没有子节点的节点称为树叶，树中的其余节点称为分支节点（分支节点可只有一个分支）；</p><p>⑤祖先和子孙：基于父节点&#x2F;子节点关系和传递性，可以确定相应的传递关系，称为祖先关系或子孙关系；</p><p>⑤度数：一个节点的子节点个数称为该节点的度数</p><p>⑥路径、路径长度：从一个祖先节点到其子孙节点的一系列边称为树中一条路径（从一棵树的根到树中任一个节点都有唯一路径），路径中边的条数称为路径的长度，认为每个节点到自身有长0的路径；</p><p>⑦节点的层数：树根到节点的路径长度是该节点的层数节点都有层数，根所在的层为0；</p><p>⑧高度（或深度）：树的高度或深度是树中节点的最大层数（最长路径的长度）加1，空树高度为0，只有根节点的树高度为1。</p><h2 id="2-二叉树的定义"><a href="#2-二叉树的定义" class="headerlink" title="2.二叉树的定义"></a>2.二叉树的定义</h2><p>二叉树（Binary Tree)是n（n&gt;&#x3D;0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p><h3 id="2-1二叉树的特点"><a href="#2-1二叉树的特点" class="headerlink" title="2.1二叉树的特点"></a>2.1二叉树的特点</h3><p>①每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点；</p><p>②左子树和右子树是由顺序的，次序不能颠倒；</p><p>③即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p><h3 id="2-2二叉树具有五种基本形态"><a href="#2-2二叉树具有五种基本形态" class="headerlink" title="2.2二叉树具有五种基本形态"></a>2.2二叉树具有五种基本形态</h3><p>①空二叉树；</p><p>②只有一个根结点；</p><p>③根结点只有左子树；</p><p>④根结点只有右子树；</p><p>⑤根结点既有左子树又有右子树。</p><h2 id="3-特殊的二叉树"><a href="#3-特殊的二叉树" class="headerlink" title="3.特殊的二叉树"></a>3.特殊的二叉树</h2><h3 id="3-1斜树"><a href="#3-1斜树" class="headerlink" title="3.1斜树"></a>3.1斜树</h3><p>所有的结点都只有左子树的二叉树叫左斜树；所有结点都是只有右子树的二叉树叫右斜树。</p><h3 id="3-2满二叉树"><a href="#3-2满二叉树" class="headerlink" title="3.2满二叉树"></a>3.2满二叉树</h3><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树就称为满二叉树，满二叉树的特点有：</p><p>①叶子只能出现在最下一层。出现在其他层就不可能达到平衡；</p><p>②非叶子结点的度一定是2；</p><p>③在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多。</p><h3 id="3-3完全二叉树"><a href="#3-3完全二叉树" class="headerlink" title="3.3完全二叉树"></a>3.3完全二叉树</h3><p>对一棵具有n个结点的二叉树按层序编号，如果编号为i(1&lt;&#x3D;i&lt;&#x3D;n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树，完全二叉树的特点：</p><p>①叶子结点只能出现在最下两层；</p><p>②最下层的叶子一定集中在左部连续位置；</p><p>③倒数二层，若有叶子结点，一定都在右部连续位置；</p><p>④如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况；</p><p>⑤同样结点数的二叉树，完全二叉树的深度最小。</p><p>注意：满二叉树一定是棵完全二叉树，但完全二叉树不一定是满的。</p><h3 id="3-4平衡二叉树"><a href="#3-4平衡二叉树" class="headerlink" title="3.4平衡二叉树"></a>3.4平衡二叉树</h3><p>平衡树，即平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>平衡二叉树的常用算法有红黑树、AVL、Treap、伸展树、SBT等。</p><h2 id="4-二叉树的性质"><a href="#4-二叉树的性质" class="headerlink" title="4.二叉树的性质"></a>4.二叉树的性质</h2><p>①在二叉树的第i层上至多有2^(i-1)个结点（i&gt;&#x3D;1)；</p><p>②深度为K的二叉树至多有2^k - 1个结点（k&gt;&#x3D;1)；</p><p>③对任何一棵二叉树T，如果其终端结点数为n0， 度为2的结点数为n2,则n0 &#x3D; n2 + 1；</p><p>④n个结点的完全二叉树的高度 k &#x3D; ⎡log2(n+1)⎤；</p><p>⑤性质5. 满二叉树里的叶结点比分支结点多一个。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找法（Binary Search）</title>
      <link href="/10008/"/>
      <url>/10008/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h2><p>对于有序的数列，才能使用二分查找法（Binary Search）。如果我们想要在一个有序的数列中查找一个目标元素target，那么可以先拿有序数列中间的元素v和target进行比较，看它们是否会相等，如果相等，则返回元素的位置；否则，整个数组就分为小于v的部分和大于v的部分。如果target小于v，那么将继续在数组小于v的部分取中间的元素和target比较；如果target大于v，则在数组中大于v的部分取中间的元素和target比较。直到找到和target相同的元素，返回元素位置，或者数组中没有目标元素，直接返回-1。</p><p>时间复杂度：O（logn）</p><h2 id="2-基本流程"><a href="#2-基本流程" class="headerlink" title="2.基本流程"></a>2.基本流程</h2><p>①取数组中间的元素v和target比较，如果刚好相等，返回元素位置；</p><p>②如果target小于v，在数组小于v的部分取中间的元素和target比较，返回步骤①；</p><p>③如果target大于v，在数组大于v的部分取中间的元素和target比较，返回步骤①；</p><p>④如果没有找到和target相等元素，返回-1。</p><h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a>3.算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找法，在有序数组arr中，查找target</span></span><br><span class="line"><span class="comment">//如果找到target，返回相应的索引index</span></span><br><span class="line"><span class="comment">//如果没有找到target，返回-1 </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(T arr[], <span class="type">int</span> n, T target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在arr[l...r]之中查找target</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="comment">//如果l和r都是int中最大的两个数，就会产生内存溢出的问题 </span></span><br><span class="line">        <span class="comment">//int mid = (l + r) / 2;</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[min] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="comment">//在arr[l...mid-1]之中查找target </span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在arr[mid+1...r]之中查找target </span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 搜索问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法之——冒泡排序（Bubble Sort）</title>
      <link href="/10004/"/>
      <url>/10004/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法，从无序的数组或者链表第一个元素开始遍历，两两相近的元素进行比较，根据预定的排序规则（升序或降序）交换两个元素的位置，以此类推，直到最后将最大（小）的数据元素交换到了无序数组或者链表的最后一个位置，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾。</p><p>时间复杂度：O（n^2）</p><h2 id="2-基本流程（升序）"><a href="#2-基本流程（升序）" class="headerlink" title="2.基本流程（升序）"></a>2.基本流程（升序）</h2><p>①比较相邻的元素，如果第一个比第二个大，就交换两个元素的位置；</p><p>②对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；</p><p>③针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）；</p><p>④持续每次对越来越少的元素（无序元素）重复上面的步骤，直到没有任何一对数字需要比较，则序列最终有序。</p><h2 id="3-流程演示"><a href="#3-流程演示" class="headerlink" title="3.流程演示"></a>3.流程演示</h2><p><img src="/img/backend/Bubble_Sort.jpg"></p><h2 id="4-算法实现（升序）"><a href="#4-算法实现（升序）" class="headerlink" title="4.算法实现（升序）"></a>4.算法实现（升序）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bubble</span>:</span><br><span class="line">    <span class="function">def <span class="title">bubbleSort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"><span class="function">        for i in range(len(nums) - <span class="number">1</span>):</span></span><br><span class="line"><span class="function">            for j in range(len(nums) - i - <span class="number">1</span>):</span></span><br><span class="line"><span class="function">                if (nums[j] &gt; nums[j + <span class="number">1</span>]):</span></span><br><span class="line"><span class="function">                    temp =</span> nums[j]</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>]</span><br><span class="line">                    nums[j + <span class="number">1</span>] = temp</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2 id="5-算法优化"><a href="#5-算法优化" class="headerlink" title="5.算法优化"></a>5.算法优化</h2><p>加个标识变量用于记录每趟冒泡排序是否发生过数据元素的位置交换，如果没有发生交换，说明序列已经有序了，不必继续进行下去了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bubble</span>:</span><br><span class="line">    <span class="function">def <span class="title">bubbleSort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"><span class="function">        for i in range(len(nums) - <span class="number">1</span>):</span></span><br><span class="line"><span class="function">            flag =</span> <span class="function">True</span></span><br><span class="line"><span class="function">            <span class="keyword">for</span> j in <span class="title">range</span><span class="params">(len(nums) - i - <span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">                if (nums[j] &gt; nums[j + <span class="number">1</span>]):</span></span><br><span class="line"><span class="function">                    temp =</span> nums[j]</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>]</span><br><span class="line">                    nums[j + <span class="number">1</span>] = temp</span><br><span class="line">                    flag = False</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之指令重排分析</title>
      <link href="/10002/"/>
      <url>/10002/</url>
      
        <content type="html"><![CDATA[<p>引言：在Java中看似顺序的代码在JVM中，可能会出现编译器或者CPU对这些操作指令进行了重新排序；在特定情况下，指令重排将会给我们的程序带来不确定的结果…..</p><h2 id="1-什么是指令重排？"><a href="#1-什么是指令重排？" class="headerlink" title="1.什么是指令重排？"></a>1.什么是指令重排？</h2><p>在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列，一般而言，这个指令序列是会输出确定的结果；以确保每一次的执行都有确定的结果。但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化，在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序，在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。</p><h2 id="2-数据依赖性"><a href="#2-数据依赖性" class="headerlink" title="2.数据依赖性"></a>2.数据依赖性</h2><p>主要指不同的程序指令之间的顺序是不允许进行交互的，即可称这些程序指令之间存在数据依赖性。 </p><p>主要的例子如下：</p><table><thead><tr><th>名称</th><th>代码示例</th><th>说明</th></tr></thead><tbody><tr><td>写后读</td><td>a &#x3D; 1;b &#x3D; a;</td><td>写一个变量之后，再读这个位置。</td></tr><tr><td>写后写</td><td>a &#x3D; 1;a &#x3D; 2;</td><td>写一个变量之后，再写这个变量。</td></tr><tr><td>读后写</td><td>a &#x3D; b;b &#x3D; 1;</td><td>读一个变量之后，再写这个变量。</td></tr></tbody></table><p>进过分析，发现这里每组指令中都有写操作，这个写操作的位置是不允许变化的，否则将带来不一样的执行结果。 </p><p>编译器将不会对存在数据依赖性的程序指令进行重排，这里的依赖性仅仅指单线程情况下的数据依赖性；多线程并发情况下，此规则将失效。</p><h2 id="3-as-if-serial语义"><a href="#3-as-if-serial语义" class="headerlink" title="3.as-if-serial语义"></a>3.as-if-serial语义</h2><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p><p>分析：  关键词是单线程情况下，必须遵守；其余的不遵守。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span>  <span class="operator">=</span> <span class="number">3.14</span>;    <span class="comment">//A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span>   <span class="operator">=</span> <span class="number">1.0</span>;     <span class="comment">//B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r; <span class="comment">//C</span></span><br></pre></td></tr></table></figure><p>分析代码：   A-&gt;C  B-&gt;C;  A,B之间不存在依赖关系； 故在单线程情况下， A与B的指令顺序是可以重排的，C不允许重排，必须在A和B之后。</p><p>结论性的总结：</p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><p>核心点还是单线程，多线程情况下不遵守此原则。</p><h2 id="4-在多线程下的指令重排"><a href="#4-在多线程下的指令重排" class="headerlink" title="4.在多线程下的指令重排"></a>4.在多线程下的指令重排</h2><p>首先我们基于一段代码的示例来分析，在多线程情况下，重排是否有不同结果信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReorderExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;             <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Public <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  a * a;        <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码，在单线程情况下，执行结果是确定的， flag&#x3D;true将被reader的方法体中看到，并正确的设置结果。 但是在多线程情况下，是否还是只有一个确定的结果呢？</p><p>假设有A和B两个线程同时来执行这个代码片段， 两个可能的执行流程如下：</p><p>可能的流程1, 由于1和2语句之间没有数据依赖关系，故两者可以重排，在两个线程之间的可能顺序如下：<br><img src="/img/backend/20160808152057670.png"></p><p>可能的流程2:， 在两个线程之间的语句执行顺序如下：<br><img src="/img/backend/20160808152105113.png"></p><p>根据happens- before的程序顺序规则，上面计算圆的面积的示例代码存在三个happens- before关系：</p><p>A happens- before B；</p><p>B happens- before C；</p><p>A happens- before C；</p><p>这里的第3个happens- before关系，是根据happens- before的传递性推导出来的  </p><p>在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义。</p><p>核心点是：两个线程之间在执行同一段代码之间的critical area，在不同的线程之间共享变量；由于执行顺序、CPU编译器对于程序指令的优化等造成了不确定的执行结果。</p><h2 id="5-指令重排的原因分析"><a href="#5-指令重排的原因分析" class="headerlink" title="5.指令重排的原因分析"></a>5.指令重排的原因分析</h2><p>主要还是编译器以及CPU为了优化代码或者执行的效率而执行的优化操作；应用条件是单线程场景下，对于并发多线程场景下，指令重排会产生不确定的执行效果。</p><h2 id="6-如何防止指令重排"><a href="#6-如何防止指令重排" class="headerlink" title="6.如何防止指令重排"></a>6.如何防止指令重排</h2><p>volatile关键字可以保证变量的可见性，因为对volatile的操作都在Main Memory中，而Main Memory是被所有线程所共享的，这里的代价就是牺牲了性能，无法利用寄存器或Cache，因为它们都不是全局的，无法保证可见性，可能产生脏读。</p><p>volatile还有一个作用就是局部阻止重排序的发生，对volatile变量的操作指令都不会被重排序，因为如果重排序，又可能产生可见性问题。</p><p>在保证可见性方面，锁（包括显式锁、对象锁）以及对原子变量的读写都可以确保变量的可见性。但是实现方式略有不同，例如同步锁保证得到锁时从内存里重新读入数据刷新缓存，释放锁时将数据写回内存以保数据可见，而volatile变量干脆都是读写内存。</p><h2 id="7-可见性"><a href="#7-可见性" class="headerlink" title="7.可见性"></a>7.可见性</h2><p>这里提到的可见性是指前一条程序指令的执行结果，可以被后一条指令读到或者看到，称之为可见性。反之为不可见性。这里主要描述的是在多线程环境下，指令语句之间对于结果信息的读取即时性。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>送给正在考场奋笔疾书的高三学子们</title>
      <link href="/10001/"/>
      <url>/10001/</url>
      
        <content type="html"><![CDATA[<p>还记得四年前的今天，我和所有的高三学子一样，坐在如战场一般的考场上奋笔疾书着。这是一场青春的战场，也是一场即不看脸又不拼爹的公平决斗，多少人十二年寒窗苦读就是为了能在这场战斗中崭露头角，让人生的起跑线能够有一个更高的起点。</p><p>但是作为一个即将大学毕业的老油条在这里要说的是，高中再努力的你，能够决定的并不是你的人生道路，而是你将来四年会在哪里打lol，那里的网速好不好，宿舍的围墙好不好翻。很多高中老师总是会这样激励自己的学生：高中的时候紧，到了大学的时候就松了。是啊，在高中的巨大学习压力下，很多人一上大学就被大学里的轻松而顿时陷入了迷茫，有些人一迷茫就是四年，四年里浑浑噩噩，无所事事，整天宅在宿舍里打游戏，最终提升了lol的段位，却丢了大学的学位。那么，努力到底有什么用呢？说实在的，努力一点儿用都没有，因为到了大学，你就会知道原来有钱人家的孩子居然可以这么有钱，时常会想有钱人的快乐是什么，但有钱人的快乐你根本就想象不到。（以上纯属瞎扯蛋）</p><p><img src="/img/notes/1496812048562094363.jpg"></p><p>还记得我的高中班主任跟我们解释过为什么中国的高考要在6月7号、8号，因为678的谐音时录取吧，可见高考的目的就是为了让考生们都能被录取，都能考上大学。高三的时候压力非常的大，一直不明白当初那么努力，到底是为了什么，那个时候心里也只有一个目标，就是考上大学，学自己喜欢的专业。上了大学之后才渐渐的明白，大学并不是简单的用来接受更高等教育的地方，大学里你可以做的事情非常多，高中的时候甚至你的每一天都有老师或家长安排你要做什么，不要做什么。但是到了大学，只要你有想法，任何事情都有可能在你身上发生，与其说大学是一个微型的社会，倒不如说大学是一个属于年轻人自己的舞台。在这里，你可以认识很多志同道合的朋友，你可以跟他们做一些自己喜欢做的事情。而在大学的这四年里，你不会有任何的压力，自己想做的事情都可以放心大胆的去做，因为你除了父母赋予你的东西，其它的一无所有，当你要去做什么事情的时候你会发现自己可以非常的大胆，一无所有的你根本就没有什么东西可以是失去的，那又为什么不放手一搏，大胆去做呢？</p><p>在我看来，对于年轻人来说，大学是一个非常重要而且必须经历的一个阶段，它除了会让你学到一定的专业知识，或许还会让你认识一群永生难忘的好朋友，或许还能收获一份美好的爱情。而这一切，完全都掌控在你自己的手里，前提就是你高中的努力，能让你在今明两天的一战中披荆斩棘，考出惊人的成绩。</p><p>最后，祝所有考生能够超常发挥，考试满意的成绩！！！</p>]]></content>
      
      
      <categories>
          
          <category> 随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学时记忆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业了，送给学弟学妹们的话</title>
      <link href="/10000/"/>
      <url>/10000/</url>
      
        <content type="html"><![CDATA[<p>也许很多人会想，大学到底是什么东西，上大学到底有什么用，其实这些问题我也想了整整四年。</p><p>大一的时候，总是会非常的迷茫，感觉不是在上大学，而是被大学上了。刚开始的时候就跟高中的一样，每天除了上课学习，就不知道要去干些什么了。不过还好，我加入了两个社团，这让我除了上课又多了一些乐趣。当然，在大一的时候最让我充满激情的还是做算法题，而我这里也慢慢的找到了自己的方向，至少在大一的时候还是目标比较明确的。虽然在大二的时候没有在算法这条道路上越走越远，但我还是学到了很多东西，这让我在以后学习其它语言时带来了很大的便利。大三课很多，但我慢慢的知道了自己要走什么方向，虽然课余时间很少，但我还是会花比较多的时间去做自己喜欢做的事情，在这期间也做了一些实际的项目。再说说大四吧，来了上海这个大城市实习，一直实习到现在，在这段时间里，见识了很多自己没有见识过的东西，也认识很多有趣的同事，慢慢地也习惯了魔都的生活模式。总之呢，我的大学也没有什么大起大落，感觉比较平淡，但是也比较充实。</p><p><img src="/img/notes/1495429290969085137.jpg"></p><p>如果你现在正处于迷茫期，不要害怕，也不要心急，在没有事情的时候多去南区图书馆，借一些自己喜欢看但又没有看的书，因为在图书馆找书的过程，其实就是在找自己。在大学里，最重要的不是要学好课堂上的每一门课程，我觉得最重要的是要找到自己，找到自己喜欢做想做的事情。如果你还没有找到，那就好好的听一听课，无论是专业课还是非专业课，上课的时候尽量坐前排，放下手机，即使不喜欢这门课，也好好听听老师讲得东西，因为能当老师的人，总有一句话会让你感触深刻。关于学习成绩，我觉得只要能保证不挂科就好了，在大学里学习不是目的，这只是成长过程中一个必要的阶段而已。多花点时间去做一些自己喜欢做的事情，放下手机，关掉电脑，走出宿舍，多去外面走一走，多交一些非本专业的朋友，多参加一下社团的活动，多去图书管逛一逛，同时也不要忘了锻炼身体，少熬夜打游戏，因为身体才是革命的本钱。四年大学下来无论收获是大是小，但一定要找到自己想做的事情，确定自己要走的方向，我们还年轻，即使是在毕业的前一天才知道自己想要的是什么，一切都还来得及。</p><p>“路漫漫其修远兮，吾将上下而求索”，一直都很喜欢这句话，因为大学就是一个探索的过程，路还很长很远，只要脚踏实地，一步一个脚印，做最真实的自己，一定会有一个美好的未来。</p>]]></content>
      
      
      <categories>
          
          <category> 随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学时记忆 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
